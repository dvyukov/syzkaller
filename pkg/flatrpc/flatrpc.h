// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
#define FLATBUFFERS_GENERATED_FLATRPC_RPC_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

namespace rpc {

struct ConnectRequest;
struct ConnectRequestBuilder;
struct ConnectRequestT;

struct ConnectReply;
struct ConnectReplyBuilder;
struct ConnectReplyT;

struct InfoRequest;
struct InfoRequestBuilder;
struct InfoRequestT;

struct InfoReply;
struct InfoReplyBuilder;
struct InfoReplyT;

struct FileInfo;
struct FileInfoBuilder;
struct FileInfoT;

struct GlobInfo;
struct GlobInfoBuilder;
struct GlobInfoT;

struct HostMessage;
struct HostMessageBuilder;
struct HostMessageT;

struct ExecutorMessage;
struct ExecutorMessageBuilder;
struct ExecutorMessageT;

struct ExecRequest;
struct ExecRequestBuilder;
struct ExecRequestT;

struct SignalUpdate;
struct SignalUpdateBuilder;
struct SignalUpdateT;

struct ExecutingMessage;
struct ExecutingMessageBuilder;
struct ExecutingMessageT;

struct StatsMessage;
struct StatsMessageBuilder;
struct StatsMessageT;

struct CallInfo;
struct CallInfoBuilder;
struct CallInfoT;

struct Comparison;

struct ProgInfo;
struct ProgInfoBuilder;
struct ProgInfoT;

struct ExecResult;
struct ExecResultBuilder;
struct ExecResultT;

enum class Feature : uint64_t {
  Coverage = 1ULL,
  Comparisons = 2ULL,
  ExtraCoverage = 4ULL,
  DelayKcovMmap = 8ULL,
  SandboxSetuid = 16ULL,
  SandboxNamespace = 32ULL,
  SandboxAndroid = 64ULL,
  Fault = 128ULL,
  Leak = 256ULL,
  NetInjection = 512ULL,
  NetDevices = 1024ULL,
  KCSAN = 2048ULL,
  DevlinkPCI = 4096ULL,
  NicVF = 8192ULL,
  USBEmulation = 16384ULL,
  VhciInjection = 32768ULL,
  WifiEmulation = 65536ULL,
  LRWPANEmulation = 131072ULL,
  BinFmtMisc = 262144ULL,
  Swap = 524288ULL,
  NONE = 0,
  ANY = 1048575ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(Feature, uint64_t)

inline const Feature (&EnumValuesFeature())[20] {
  static const Feature values[] = {
    Feature::Coverage,
    Feature::Comparisons,
    Feature::ExtraCoverage,
    Feature::DelayKcovMmap,
    Feature::SandboxSetuid,
    Feature::SandboxNamespace,
    Feature::SandboxAndroid,
    Feature::Fault,
    Feature::Leak,
    Feature::NetInjection,
    Feature::NetDevices,
    Feature::KCSAN,
    Feature::DevlinkPCI,
    Feature::NicVF,
    Feature::USBEmulation,
    Feature::VhciInjection,
    Feature::WifiEmulation,
    Feature::LRWPANEmulation,
    Feature::BinFmtMisc,
    Feature::Swap
  };
  return values;
}

inline const char *EnumNameFeature(Feature e) {
  switch (e) {
    case Feature::Coverage: return "Coverage";
    case Feature::Comparisons: return "Comparisons";
    case Feature::ExtraCoverage: return "ExtraCoverage";
    case Feature::DelayKcovMmap: return "DelayKcovMmap";
    case Feature::SandboxSetuid: return "SandboxSetuid";
    case Feature::SandboxNamespace: return "SandboxNamespace";
    case Feature::SandboxAndroid: return "SandboxAndroid";
    case Feature::Fault: return "Fault";
    case Feature::Leak: return "Leak";
    case Feature::NetInjection: return "NetInjection";
    case Feature::NetDevices: return "NetDevices";
    case Feature::KCSAN: return "KCSAN";
    case Feature::DevlinkPCI: return "DevlinkPCI";
    case Feature::NicVF: return "NicVF";
    case Feature::USBEmulation: return "USBEmulation";
    case Feature::VhciInjection: return "VhciInjection";
    case Feature::WifiEmulation: return "WifiEmulation";
    case Feature::LRWPANEmulation: return "LRWPANEmulation";
    case Feature::BinFmtMisc: return "BinFmtMisc";
    case Feature::Swap: return "Swap";
    default: return "";
  }
}

enum class HostMessages : uint8_t {
  NONE = 0,
  ExecRequest = 1,
  SignalUpdate = 2,
  MIN = NONE,
  MAX = SignalUpdate
};

inline const HostMessages (&EnumValuesHostMessages())[3] {
  static const HostMessages values[] = {
    HostMessages::NONE,
    HostMessages::ExecRequest,
    HostMessages::SignalUpdate
  };
  return values;
}

inline const char * const *EnumNamesHostMessages() {
  static const char * const names[4] = {
    "NONE",
    "ExecRequest",
    "SignalUpdate",
    nullptr
  };
  return names;
}

inline const char *EnumNameHostMessages(HostMessages e) {
  if (flatbuffers::IsOutRange(e, HostMessages::NONE, HostMessages::SignalUpdate)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesHostMessages()[index];
}

template<typename T> struct HostMessagesTraits {
  static const HostMessages enum_value = HostMessages::NONE;
};

template<> struct HostMessagesTraits<rpc::ExecRequest> {
  static const HostMessages enum_value = HostMessages::ExecRequest;
};

template<> struct HostMessagesTraits<rpc::SignalUpdate> {
  static const HostMessages enum_value = HostMessages::SignalUpdate;
};

template<typename T> struct HostMessagesUnionTraits {
  static const HostMessages enum_value = HostMessages::NONE;
};

template<> struct HostMessagesUnionTraits<rpc::ExecRequestT> {
  static const HostMessages enum_value = HostMessages::ExecRequest;
};

template<> struct HostMessagesUnionTraits<rpc::SignalUpdateT> {
  static const HostMessages enum_value = HostMessages::SignalUpdate;
};

struct HostMessagesUnion {
  HostMessages type;
  void *value;

  HostMessagesUnion() : type(HostMessages::NONE), value(nullptr) {}
  HostMessagesUnion(HostMessagesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(HostMessages::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  HostMessagesUnion(const HostMessagesUnion &);
  HostMessagesUnion &operator=(const HostMessagesUnion &u)
    { HostMessagesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  HostMessagesUnion &operator=(HostMessagesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~HostMessagesUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = HostMessagesUnionTraits<RT>::enum_value;
    if (type != HostMessages::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, HostMessages type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecRequestT *AsExecRequest() {
    return type == HostMessages::ExecRequest ?
      reinterpret_cast<rpc::ExecRequestT *>(value) : nullptr;
  }
  const rpc::ExecRequestT *AsExecRequest() const {
    return type == HostMessages::ExecRequest ?
      reinterpret_cast<const rpc::ExecRequestT *>(value) : nullptr;
  }
  rpc::SignalUpdateT *AsSignalUpdate() {
    return type == HostMessages::SignalUpdate ?
      reinterpret_cast<rpc::SignalUpdateT *>(value) : nullptr;
  }
  const rpc::SignalUpdateT *AsSignalUpdate() const {
    return type == HostMessages::SignalUpdate ?
      reinterpret_cast<const rpc::SignalUpdateT *>(value) : nullptr;
  }
};

bool VerifyHostMessages(flatbuffers::Verifier &verifier, const void *obj, HostMessages type);
bool VerifyHostMessagesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessages> *types);

enum class ExecutorMessages : uint8_t {
  NONE = 0,
  ExecResult = 1,
  Executing = 2,
  Stats = 3,
  MIN = NONE,
  MAX = Stats
};

inline const ExecutorMessages (&EnumValuesExecutorMessages())[4] {
  static const ExecutorMessages values[] = {
    ExecutorMessages::NONE,
    ExecutorMessages::ExecResult,
    ExecutorMessages::Executing,
    ExecutorMessages::Stats
  };
  return values;
}

inline const char * const *EnumNamesExecutorMessages() {
  static const char * const names[5] = {
    "NONE",
    "ExecResult",
    "Executing",
    "Stats",
    nullptr
  };
  return names;
}

inline const char *EnumNameExecutorMessages(ExecutorMessages e) {
  if (flatbuffers::IsOutRange(e, ExecutorMessages::NONE, ExecutorMessages::Stats)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExecutorMessages()[index];
}

template<typename T> struct ExecutorMessagesTraits {
  static const ExecutorMessages enum_value = ExecutorMessages::NONE;
};

template<> struct ExecutorMessagesTraits<rpc::ExecResult> {
  static const ExecutorMessages enum_value = ExecutorMessages::ExecResult;
};

template<> struct ExecutorMessagesTraits<rpc::ExecutingMessage> {
  static const ExecutorMessages enum_value = ExecutorMessages::Executing;
};

template<> struct ExecutorMessagesTraits<rpc::StatsMessage> {
  static const ExecutorMessages enum_value = ExecutorMessages::Stats;
};

template<typename T> struct ExecutorMessagesUnionTraits {
  static const ExecutorMessages enum_value = ExecutorMessages::NONE;
};

template<> struct ExecutorMessagesUnionTraits<rpc::ExecResultT> {
  static const ExecutorMessages enum_value = ExecutorMessages::ExecResult;
};

template<> struct ExecutorMessagesUnionTraits<rpc::ExecutingMessageT> {
  static const ExecutorMessages enum_value = ExecutorMessages::Executing;
};

template<> struct ExecutorMessagesUnionTraits<rpc::StatsMessageT> {
  static const ExecutorMessages enum_value = ExecutorMessages::Stats;
};

struct ExecutorMessagesUnion {
  ExecutorMessages type;
  void *value;

  ExecutorMessagesUnion() : type(ExecutorMessages::NONE), value(nullptr) {}
  ExecutorMessagesUnion(ExecutorMessagesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ExecutorMessages::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ExecutorMessagesUnion(const ExecutorMessagesUnion &);
  ExecutorMessagesUnion &operator=(const ExecutorMessagesUnion &u)
    { ExecutorMessagesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ExecutorMessagesUnion &operator=(ExecutorMessagesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ExecutorMessagesUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ExecutorMessagesUnionTraits<RT>::enum_value;
    if (type != ExecutorMessages::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ExecutorMessages type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  rpc::ExecResultT *AsExecResult() {
    return type == ExecutorMessages::ExecResult ?
      reinterpret_cast<rpc::ExecResultT *>(value) : nullptr;
  }
  const rpc::ExecResultT *AsExecResult() const {
    return type == ExecutorMessages::ExecResult ?
      reinterpret_cast<const rpc::ExecResultT *>(value) : nullptr;
  }
  rpc::ExecutingMessageT *AsExecuting() {
    return type == ExecutorMessages::Executing ?
      reinterpret_cast<rpc::ExecutingMessageT *>(value) : nullptr;
  }
  const rpc::ExecutingMessageT *AsExecuting() const {
    return type == ExecutorMessages::Executing ?
      reinterpret_cast<const rpc::ExecutingMessageT *>(value) : nullptr;
  }
  rpc::StatsMessageT *AsStats() {
    return type == ExecutorMessages::Stats ?
      reinterpret_cast<rpc::StatsMessageT *>(value) : nullptr;
  }
  const rpc::StatsMessageT *AsStats() const {
    return type == ExecutorMessages::Stats ?
      reinterpret_cast<const rpc::StatsMessageT *>(value) : nullptr;
  }
};

bool VerifyExecutorMessages(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessages type);
bool VerifyExecutorMessagesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessages> *types);

enum class RequestFlag : uint64_t {
  IsBinary = 1ULL,
  NewSignal = 2ULL,
  ResetState = 4ULL,
  ReturnOutput = 8ULL,
  ReturnError = 16ULL,
  NONE = 0,
  ANY = 31ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(RequestFlag, uint64_t)

inline const RequestFlag (&EnumValuesRequestFlag())[5] {
  static const RequestFlag values[] = {
    RequestFlag::IsBinary,
    RequestFlag::NewSignal,
    RequestFlag::ResetState,
    RequestFlag::ReturnOutput,
    RequestFlag::ReturnError
  };
  return values;
}

inline const char * const *EnumNamesRequestFlag() {
  static const char * const names[17] = {
    "IsBinary",
    "NewSignal",
    "",
    "ResetState",
    "",
    "",
    "",
    "ReturnOutput",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ReturnError",
    nullptr
  };
  return names;
}

inline const char *EnumNameRequestFlag(RequestFlag e) {
  if (flatbuffers::IsOutRange(e, RequestFlag::IsBinary, RequestFlag::ReturnError)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(RequestFlag::IsBinary);
  return EnumNamesRequestFlag()[index];
}

enum class ExecEnv : uint64_t {
  Debug = 1ULL,
  Signal = 2ULL,
  SandboxSetuid = 4ULL,
  SandboxNamespace = 8ULL,
  SandboxAndroid = 16ULL,
  ExtraCover = 32ULL,
  EnableTun = 64ULL,
  EnableNetDev = 128ULL,
  EnableNetReset = 256ULL,
  EnableCgroups = 512ULL,
  EnableCloseFds = 1024ULL,
  EnableDevlinkPCI = 2048ULL,
  EnableVhciInjection = 4096ULL,
  EnableWifi = 8192ULL,
  DelayKcovMmap = 16384ULL,
  EnableNicVF = 32768ULL,
  NONE = 0,
  ANY = 65535ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecEnv, uint64_t)

inline const ExecEnv (&EnumValuesExecEnv())[16] {
  static const ExecEnv values[] = {
    ExecEnv::Debug,
    ExecEnv::Signal,
    ExecEnv::SandboxSetuid,
    ExecEnv::SandboxNamespace,
    ExecEnv::SandboxAndroid,
    ExecEnv::ExtraCover,
    ExecEnv::EnableTun,
    ExecEnv::EnableNetDev,
    ExecEnv::EnableNetReset,
    ExecEnv::EnableCgroups,
    ExecEnv::EnableCloseFds,
    ExecEnv::EnableDevlinkPCI,
    ExecEnv::EnableVhciInjection,
    ExecEnv::EnableWifi,
    ExecEnv::DelayKcovMmap,
    ExecEnv::EnableNicVF
  };
  return values;
}

inline const char *EnumNameExecEnv(ExecEnv e) {
  switch (e) {
    case ExecEnv::Debug: return "Debug";
    case ExecEnv::Signal: return "Signal";
    case ExecEnv::SandboxSetuid: return "SandboxSetuid";
    case ExecEnv::SandboxNamespace: return "SandboxNamespace";
    case ExecEnv::SandboxAndroid: return "SandboxAndroid";
    case ExecEnv::ExtraCover: return "ExtraCover";
    case ExecEnv::EnableTun: return "EnableTun";
    case ExecEnv::EnableNetDev: return "EnableNetDev";
    case ExecEnv::EnableNetReset: return "EnableNetReset";
    case ExecEnv::EnableCgroups: return "EnableCgroups";
    case ExecEnv::EnableCloseFds: return "EnableCloseFds";
    case ExecEnv::EnableDevlinkPCI: return "EnableDevlinkPCI";
    case ExecEnv::EnableVhciInjection: return "EnableVhciInjection";
    case ExecEnv::EnableWifi: return "EnableWifi";
    case ExecEnv::DelayKcovMmap: return "DelayKcovMmap";
    case ExecEnv::EnableNicVF: return "EnableNicVF";
    default: return "";
  }
}

enum class ExecFlag : uint64_t {
  CollectSignal = 1ULL,
  CollectCover = 2ULL,
  DedupCover = 4ULL,
  CollectComps = 8ULL,
  Threaded = 16ULL,
  CoverFilter = 32ULL,
  NONE = 0,
  ANY = 63ULL
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(ExecFlag, uint64_t)

inline const ExecFlag (&EnumValuesExecFlag())[6] {
  static const ExecFlag values[] = {
    ExecFlag::CollectSignal,
    ExecFlag::CollectCover,
    ExecFlag::DedupCover,
    ExecFlag::CollectComps,
    ExecFlag::Threaded,
    ExecFlag::CoverFilter
  };
  return values;
}

inline const char *EnumNameExecFlag(ExecFlag e) {
  switch (e) {
    case ExecFlag::CollectSignal: return "CollectSignal";
    case ExecFlag::CollectCover: return "CollectCover";
    case ExecFlag::DedupCover: return "DedupCover";
    case ExecFlag::CollectComps: return "CollectComps";
    case ExecFlag::Threaded: return "Threaded";
    case ExecFlag::CoverFilter: return "CoverFilter";
    default: return "";
  }
}

enum class CallFlag : uint8_t {
  Executed = 1,
  Finished = 2,
  Blocked = 4,
  FaultInjected = 8,
  NONE = 0,
  ANY = 15
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(CallFlag, uint8_t)

inline const CallFlag (&EnumValuesCallFlag())[4] {
  static const CallFlag values[] = {
    CallFlag::Executed,
    CallFlag::Finished,
    CallFlag::Blocked,
    CallFlag::FaultInjected
  };
  return values;
}

inline const char * const *EnumNamesCallFlag() {
  static const char * const names[9] = {
    "Executed",
    "Finished",
    "",
    "Blocked",
    "",
    "",
    "",
    "FaultInjected",
    nullptr
  };
  return names;
}

inline const char *EnumNameCallFlag(CallFlag e) {
  if (flatbuffers::IsOutRange(e, CallFlag::Executed, CallFlag::FaultInjected)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CallFlag::Executed);
  return EnumNamesCallFlag()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Comparison FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t op1_;
  uint64_t op2_;

 public:
  Comparison()
      : op1_(0),
        op2_(0) {
  }
  Comparison(uint64_t _op1, uint64_t _op2)
      : op1_(flatbuffers::EndianScalar(_op1)),
        op2_(flatbuffers::EndianScalar(_op2)) {
  }
  uint64_t op1() const {
    return flatbuffers::EndianScalar(op1_);
  }
  uint64_t op2() const {
    return flatbuffers::EndianScalar(op2_);
  }
};
FLATBUFFERS_STRUCT_END(Comparison, 16);

struct ConnectRequestT : public flatbuffers::NativeTable {
  typedef ConnectRequest TableType;
  std::string name{};
  std::string arch{};
  std::string git_revision{};
  std::string syz_revision{};
};

struct ConnectRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectRequestT NativeTableType;
  typedef ConnectRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ARCH = 6,
    VT_GIT_REVISION = 8,
    VT_SYZ_REVISION = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *arch() const {
    return GetPointer<const flatbuffers::String *>(VT_ARCH);
  }
  const flatbuffers::String *git_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_GIT_REVISION);
  }
  const flatbuffers::String *syz_revision() const {
    return GetPointer<const flatbuffers::String *>(VT_SYZ_REVISION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ARCH) &&
           verifier.VerifyString(arch()) &&
           VerifyOffset(verifier, VT_GIT_REVISION) &&
           verifier.VerifyString(git_revision()) &&
           VerifyOffset(verifier, VT_SYZ_REVISION) &&
           verifier.VerifyString(syz_revision()) &&
           verifier.EndTable();
  }
  ConnectRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectRequestBuilder {
  typedef ConnectRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ConnectRequest::VT_NAME, name);
  }
  void add_arch(flatbuffers::Offset<flatbuffers::String> arch) {
    fbb_.AddOffset(ConnectRequest::VT_ARCH, arch);
  }
  void add_git_revision(flatbuffers::Offset<flatbuffers::String> git_revision) {
    fbb_.AddOffset(ConnectRequest::VT_GIT_REVISION, git_revision);
  }
  void add_syz_revision(flatbuffers::Offset<flatbuffers::String> syz_revision) {
    fbb_.AddOffset(ConnectRequest::VT_SYZ_REVISION, syz_revision);
  }
  explicit ConnectRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectRequest> CreateConnectRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> arch = 0,
    flatbuffers::Offset<flatbuffers::String> git_revision = 0,
    flatbuffers::Offset<flatbuffers::String> syz_revision = 0) {
  ConnectRequestBuilder builder_(_fbb);
  builder_.add_syz_revision(syz_revision);
  builder_.add_git_revision(git_revision);
  builder_.add_arch(arch);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectRequest> CreateConnectRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *arch = nullptr,
    const char *git_revision = nullptr,
    const char *syz_revision = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto arch__ = arch ? _fbb.CreateString(arch) : 0;
  auto git_revision__ = git_revision ? _fbb.CreateString(git_revision) : 0;
  auto syz_revision__ = syz_revision ? _fbb.CreateString(syz_revision) : 0;
  return rpc::CreateConnectRequest(
      _fbb,
      name__,
      arch__,
      git_revision__,
      syz_revision__);
}

flatbuffers::Offset<ConnectRequest> CreateConnectRequest(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConnectReplyT : public flatbuffers::NativeTable {
  typedef ConnectReply TableType;
  std::vector<std::string> leak_frames{};
  std::vector<std::string> race_frames{};
  rpc::Feature features = static_cast<rpc::Feature>(0);
  std::vector<std::string> files{};
  std::vector<std::string> globs{};
};

struct ConnectReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectReplyT NativeTableType;
  typedef ConnectReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEAK_FRAMES = 4,
    VT_RACE_FRAMES = 6,
    VT_FEATURES = 8,
    VT_FILES = 10,
    VT_GLOBS = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_LEAK_FRAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *race_frames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RACE_FRAMES);
  }
  rpc::Feature features() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_FEATURES, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_GLOBS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LEAK_FRAMES) &&
           verifier.VerifyVector(leak_frames()) &&
           verifier.VerifyVectorOfStrings(leak_frames()) &&
           VerifyOffset(verifier, VT_RACE_FRAMES) &&
           verifier.VerifyVector(race_frames()) &&
           verifier.VerifyVectorOfStrings(race_frames()) &&
           VerifyField<uint64_t>(verifier, VT_FEATURES, 8) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfStrings(globs()) &&
           verifier.EndTable();
  }
  ConnectReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConnectReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ConnectReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ConnectReplyBuilder {
  typedef ConnectReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leak_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames) {
    fbb_.AddOffset(ConnectReply::VT_LEAK_FRAMES, leak_frames);
  }
  void add_race_frames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames) {
    fbb_.AddOffset(ConnectReply::VT_RACE_FRAMES, race_frames);
  }
  void add_features(rpc::Feature features) {
    fbb_.AddElement<uint64_t>(ConnectReply::VT_FEATURES, static_cast<uint64_t>(features), 0);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(ConnectReply::VT_FILES, files);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs) {
    fbb_.AddOffset(ConnectReply::VT_GLOBS, globs);
  }
  explicit ConnectReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConnectReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConnectReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConnectReply> CreateConnectReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> leak_frames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> race_frames = 0,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> globs = 0) {
  ConnectReplyBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_globs(globs);
  builder_.add_files(files);
  builder_.add_race_frames(race_frames);
  builder_.add_leak_frames(leak_frames);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConnectReply> CreateConnectReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *leak_frames = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *race_frames = nullptr,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *globs = nullptr) {
  auto leak_frames__ = leak_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*leak_frames) : 0;
  auto race_frames__ = race_frames ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*race_frames) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*globs) : 0;
  return rpc::CreateConnectReply(
      _fbb,
      leak_frames__,
      race_frames__,
      features,
      files__,
      globs__);
}

flatbuffers::Offset<ConnectReply> CreateConnectReply(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoRequestT : public flatbuffers::NativeTable {
  typedef InfoRequest TableType;
  std::string error{};
  rpc::Feature features = static_cast<rpc::Feature>(0);
  std::vector<std::unique_ptr<rpc::GlobInfoT>> globs{};
  std::vector<std::unique_ptr<rpc::FileInfoT>> files{};
  InfoRequestT() = default;
  InfoRequestT(const InfoRequestT &o);
  InfoRequestT(InfoRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  InfoRequestT &operator=(InfoRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct InfoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoRequestT NativeTableType;
  typedef InfoRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR = 4,
    VT_FEATURES = 6,
    VT_GLOBS = 8,
    VT_FILES = 10
  };
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  rpc::Feature features() const {
    return static_cast<rpc::Feature>(GetField<uint64_t>(VT_FEATURES, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfo>> *globs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfo>> *>(VT_GLOBS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfo>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfo>> *>(VT_FILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyField<uint64_t>(verifier, VT_FEATURES, 8) &&
           VerifyOffset(verifier, VT_GLOBS) &&
           verifier.VerifyVector(globs()) &&
           verifier.VerifyVectorOfTables(globs()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           verifier.EndTable();
  }
  InfoRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoRequestBuilder {
  typedef InfoRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(InfoRequest::VT_ERROR, error);
  }
  void add_features(rpc::Feature features) {
    fbb_.AddElement<uint64_t>(InfoRequest::VT_FEATURES, static_cast<uint64_t>(features), 0);
  }
  void add_globs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfo>>> globs) {
    fbb_.AddOffset(InfoRequest::VT_GLOBS, globs);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfo>>> files) {
    fbb_.AddOffset(InfoRequest::VT_FILES, files);
  }
  explicit InfoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoRequest> CreateInfoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::GlobInfo>>> globs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::FileInfo>>> files = 0) {
  InfoRequestBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_files(files);
  builder_.add_globs(globs);
  builder_.add_error(error);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoRequest> CreateInfoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *error = nullptr,
    rpc::Feature features = static_cast<rpc::Feature>(0),
    const std::vector<flatbuffers::Offset<rpc::GlobInfo>> *globs = nullptr,
    const std::vector<flatbuffers::Offset<rpc::FileInfo>> *files = nullptr) {
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto globs__ = globs ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfo>>(*globs) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfo>>(*files) : 0;
  return rpc::CreateInfoRequest(
      _fbb,
      error__,
      features,
      globs__,
      files__);
}

flatbuffers::Offset<InfoRequest> CreateInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InfoReplyT : public flatbuffers::NativeTable {
  typedef InfoReply TableType;
  std::vector<uint32_t> cover_filter{};
};

struct InfoReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InfoReplyT NativeTableType;
  typedef InfoReplyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COVER_FILTER = 4
  };
  const flatbuffers::Vector<uint32_t> *cover_filter() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_COVER_FILTER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COVER_FILTER) &&
           verifier.VerifyVector(cover_filter()) &&
           verifier.EndTable();
  }
  InfoReplyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InfoReplyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<InfoReply> Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct InfoReplyBuilder {
  typedef InfoReply Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cover_filter(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cover_filter) {
    fbb_.AddOffset(InfoReply::VT_COVER_FILTER, cover_filter);
  }
  explicit InfoReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InfoReply> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InfoReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<InfoReply> CreateInfoReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cover_filter = 0) {
  InfoReplyBuilder builder_(_fbb);
  builder_.add_cover_filter(cover_filter);
  return builder_.Finish();
}

inline flatbuffers::Offset<InfoReply> CreateInfoReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *cover_filter = nullptr) {
  auto cover_filter__ = cover_filter ? _fbb.CreateVector<uint32_t>(*cover_filter) : 0;
  return rpc::CreateInfoReply(
      _fbb,
      cover_filter__);
}

flatbuffers::Offset<InfoReply> CreateInfoReply(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FileInfoT : public flatbuffers::NativeTable {
  typedef FileInfo TableType;
  std::string name{};
  bool exists = false;
  std::string error{};
  std::vector<uint8_t> data{};
};

struct FileInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FileInfoT NativeTableType;
  typedef FileInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_EXISTS = 6,
    VT_ERROR = 8,
    VT_DATA = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS, 1) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  FileInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FileInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FileInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FileInfoBuilder {
  typedef FileInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FileInfo::VT_NAME, name);
  }
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(FileInfo::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(FileInfo::VT_ERROR, error);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(FileInfo::VT_DATA, data);
  }
  explicit FileInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FileInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileInfo> CreateFileInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool exists = false,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  FileInfoBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_error(error);
  builder_.add_name(name);
  builder_.add_exists(exists);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileInfo> CreateFileInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool exists = false,
    const char *error = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return rpc::CreateFileInfo(
      _fbb,
      name__,
      exists,
      error__,
      data__);
}

flatbuffers::Offset<FileInfo> CreateFileInfo(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GlobInfoT : public flatbuffers::NativeTable {
  typedef GlobInfo TableType;
  std::string name{};
  std::vector<std::string> files{};
};

struct GlobInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GlobInfoT NativeTableType;
  typedef GlobInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FILES = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_FILES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.VerifyVector(files()) &&
           verifier.VerifyVectorOfStrings(files()) &&
           verifier.EndTable();
  }
  GlobInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GlobInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GlobInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GlobInfoBuilder {
  typedef GlobInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GlobInfo::VT_NAME, name);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files) {
    fbb_.AddOffset(GlobInfo::VT_FILES, files);
  }
  explicit GlobInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GlobInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GlobInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<GlobInfo> CreateGlobInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> files = 0) {
  GlobInfoBuilder builder_(_fbb);
  builder_.add_files(files);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<GlobInfo> CreateGlobInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *files = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto files__ = files ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*files) : 0;
  return rpc::CreateGlobInfo(
      _fbb,
      name__,
      files__);
}

flatbuffers::Offset<GlobInfo> CreateGlobInfo(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HostMessageT : public flatbuffers::NativeTable {
  typedef HostMessage TableType;
  rpc::HostMessagesUnion msg{};
};

struct HostMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HostMessageT NativeTableType;
  typedef HostMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::HostMessages msg_type() const {
    return static_cast<rpc::HostMessages>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecRequest *msg_as_ExecRequest() const {
    return msg_type() == rpc::HostMessages::ExecRequest ? static_cast<const rpc::ExecRequest *>(msg()) : nullptr;
  }
  const rpc::SignalUpdate *msg_as_SignalUpdate() const {
    return msg_type() == rpc::HostMessages::SignalUpdate ? static_cast<const rpc::SignalUpdate *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyHostMessages(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  HostMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HostMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HostMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecRequest *HostMessage::msg_as<rpc::ExecRequest>() const {
  return msg_as_ExecRequest();
}

template<> inline const rpc::SignalUpdate *HostMessage::msg_as<rpc::SignalUpdate>() const {
  return msg_as_SignalUpdate();
}

struct HostMessageBuilder {
  typedef HostMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::HostMessages msg_type) {
    fbb_.AddElement<uint8_t>(HostMessage::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(HostMessage::VT_MSG, msg);
  }
  explicit HostMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HostMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HostMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<HostMessage> CreateHostMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::HostMessages msg_type = rpc::HostMessages::NONE,
    flatbuffers::Offset<void> msg = 0) {
  HostMessageBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<HostMessage> CreateHostMessage(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutorMessageT : public flatbuffers::NativeTable {
  typedef ExecutorMessage TableType;
  rpc::ExecutorMessagesUnion msg{};
};

struct ExecutorMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutorMessageT NativeTableType;
  typedef ExecutorMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MSG_TYPE = 4,
    VT_MSG = 6
  };
  rpc::ExecutorMessages msg_type() const {
    return static_cast<rpc::ExecutorMessages>(GetField<uint8_t>(VT_MSG_TYPE, 0));
  }
  const void *msg() const {
    return GetPointer<const void *>(VT_MSG);
  }
  template<typename T> const T *msg_as() const;
  const rpc::ExecResult *msg_as_ExecResult() const {
    return msg_type() == rpc::ExecutorMessages::ExecResult ? static_cast<const rpc::ExecResult *>(msg()) : nullptr;
  }
  const rpc::ExecutingMessage *msg_as_Executing() const {
    return msg_type() == rpc::ExecutorMessages::Executing ? static_cast<const rpc::ExecutingMessage *>(msg()) : nullptr;
  }
  const rpc::StatsMessage *msg_as_Stats() const {
    return msg_type() == rpc::ExecutorMessages::Stats ? static_cast<const rpc::StatsMessage *>(msg()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MSG_TYPE, 1) &&
           VerifyOffset(verifier, VT_MSG) &&
           VerifyExecutorMessages(verifier, msg(), msg_type()) &&
           verifier.EndTable();
  }
  ExecutorMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutorMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutorMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const rpc::ExecResult *ExecutorMessage::msg_as<rpc::ExecResult>() const {
  return msg_as_ExecResult();
}

template<> inline const rpc::ExecutingMessage *ExecutorMessage::msg_as<rpc::ExecutingMessage>() const {
  return msg_as_Executing();
}

template<> inline const rpc::StatsMessage *ExecutorMessage::msg_as<rpc::StatsMessage>() const {
  return msg_as_Stats();
}

struct ExecutorMessageBuilder {
  typedef ExecutorMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg_type(rpc::ExecutorMessages msg_type) {
    fbb_.AddElement<uint8_t>(ExecutorMessage::VT_MSG_TYPE, static_cast<uint8_t>(msg_type), 0);
  }
  void add_msg(flatbuffers::Offset<void> msg) {
    fbb_.AddOffset(ExecutorMessage::VT_MSG, msg);
  }
  explicit ExecutorMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutorMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutorMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutorMessage> CreateExecutorMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::ExecutorMessages msg_type = rpc::ExecutorMessages::NONE,
    flatbuffers::Offset<void> msg = 0) {
  ExecutorMessageBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_msg_type(msg_type);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutorMessage> CreateExecutorMessage(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecRequestT : public flatbuffers::NativeTable {
  typedef ExecRequest TableType;
  int64_t id = 0;
  std::vector<uint8_t> prog_data{};
  rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0);
  rpc::ExecEnv exec_env = static_cast<rpc::ExecEnv>(0);
  rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0);
  int64_t sandbox_arg = 0;
  std::vector<uint32_t> signal_filter{};
  int32_t signal_filter_call = 0;
  int32_t repeat = 0;
};

struct ExecRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecRequestT NativeTableType;
  typedef ExecRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROG_DATA = 6,
    VT_FLAGS = 8,
    VT_EXEC_ENV = 10,
    VT_EXEC_FLAGS = 12,
    VT_SANDBOX_ARG = 14,
    VT_SIGNAL_FILTER = 16,
    VT_SIGNAL_FILTER_CALL = 18,
    VT_REPEAT = 20
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  const flatbuffers::Vector<uint8_t> *prog_data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_PROG_DATA);
  }
  rpc::RequestFlag flags() const {
    return static_cast<rpc::RequestFlag>(GetField<uint64_t>(VT_FLAGS, 0));
  }
  rpc::ExecEnv exec_env() const {
    return static_cast<rpc::ExecEnv>(GetField<uint64_t>(VT_EXEC_ENV, 0));
  }
  rpc::ExecFlag exec_flags() const {
    return static_cast<rpc::ExecFlag>(GetField<uint64_t>(VT_EXEC_FLAGS, 0));
  }
  int64_t sandbox_arg() const {
    return GetField<int64_t>(VT_SANDBOX_ARG, 0);
  }
  const flatbuffers::Vector<uint32_t> *signal_filter() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SIGNAL_FILTER);
  }
  int32_t signal_filter_call() const {
    return GetField<int32_t>(VT_SIGNAL_FILTER_CALL, 0);
  }
  int32_t repeat() const {
    return GetField<int32_t>(VT_REPEAT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyOffset(verifier, VT_PROG_DATA) &&
           verifier.VerifyVector(prog_data()) &&
           VerifyField<uint64_t>(verifier, VT_FLAGS, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXEC_ENV, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXEC_FLAGS, 8) &&
           VerifyField<int64_t>(verifier, VT_SANDBOX_ARG, 8) &&
           VerifyOffset(verifier, VT_SIGNAL_FILTER) &&
           verifier.VerifyVector(signal_filter()) &&
           VerifyField<int32_t>(verifier, VT_SIGNAL_FILTER_CALL, 4) &&
           VerifyField<int32_t>(verifier, VT_REPEAT, 4) &&
           verifier.EndTable();
  }
  ExecRequestT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecRequestT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecRequest> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecRequestBuilder {
  typedef ExecRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecRequest::VT_ID, id, 0);
  }
  void add_prog_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data) {
    fbb_.AddOffset(ExecRequest::VT_PROG_DATA, prog_data);
  }
  void add_flags(rpc::RequestFlag flags) {
    fbb_.AddElement<uint64_t>(ExecRequest::VT_FLAGS, static_cast<uint64_t>(flags), 0);
  }
  void add_exec_env(rpc::ExecEnv exec_env) {
    fbb_.AddElement<uint64_t>(ExecRequest::VT_EXEC_ENV, static_cast<uint64_t>(exec_env), 0);
  }
  void add_exec_flags(rpc::ExecFlag exec_flags) {
    fbb_.AddElement<uint64_t>(ExecRequest::VT_EXEC_FLAGS, static_cast<uint64_t>(exec_flags), 0);
  }
  void add_sandbox_arg(int64_t sandbox_arg) {
    fbb_.AddElement<int64_t>(ExecRequest::VT_SANDBOX_ARG, sandbox_arg, 0);
  }
  void add_signal_filter(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> signal_filter) {
    fbb_.AddOffset(ExecRequest::VT_SIGNAL_FILTER, signal_filter);
  }
  void add_signal_filter_call(int32_t signal_filter_call) {
    fbb_.AddElement<int32_t>(ExecRequest::VT_SIGNAL_FILTER_CALL, signal_filter_call, 0);
  }
  void add_repeat(int32_t repeat) {
    fbb_.AddElement<int32_t>(ExecRequest::VT_REPEAT, repeat, 0);
  }
  explicit ExecRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecRequest> CreateExecRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> prog_data = 0,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    rpc::ExecEnv exec_env = static_cast<rpc::ExecEnv>(0),
    rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0),
    int64_t sandbox_arg = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> signal_filter = 0,
    int32_t signal_filter_call = 0,
    int32_t repeat = 0) {
  ExecRequestBuilder builder_(_fbb);
  builder_.add_sandbox_arg(sandbox_arg);
  builder_.add_exec_flags(exec_flags);
  builder_.add_exec_env(exec_env);
  builder_.add_flags(flags);
  builder_.add_id(id);
  builder_.add_repeat(repeat);
  builder_.add_signal_filter_call(signal_filter_call);
  builder_.add_signal_filter(signal_filter);
  builder_.add_prog_data(prog_data);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecRequest> CreateExecRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    const std::vector<uint8_t> *prog_data = nullptr,
    rpc::RequestFlag flags = static_cast<rpc::RequestFlag>(0),
    rpc::ExecEnv exec_env = static_cast<rpc::ExecEnv>(0),
    rpc::ExecFlag exec_flags = static_cast<rpc::ExecFlag>(0),
    int64_t sandbox_arg = 0,
    const std::vector<uint32_t> *signal_filter = nullptr,
    int32_t signal_filter_call = 0,
    int32_t repeat = 0) {
  auto prog_data__ = prog_data ? _fbb.CreateVector<uint8_t>(*prog_data) : 0;
  auto signal_filter__ = signal_filter ? _fbb.CreateVector<uint32_t>(*signal_filter) : 0;
  return rpc::CreateExecRequest(
      _fbb,
      id,
      prog_data__,
      flags,
      exec_env,
      exec_flags,
      sandbox_arg,
      signal_filter__,
      signal_filter_call,
      repeat);
}

flatbuffers::Offset<ExecRequest> CreateExecRequest(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SignalUpdateT : public flatbuffers::NativeTable {
  typedef SignalUpdate TableType;
  std::vector<uint32_t> new_max{};
  std::vector<uint32_t> drop_max{};
};

struct SignalUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SignalUpdateT NativeTableType;
  typedef SignalUpdateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_MAX = 4,
    VT_DROP_MAX = 6
  };
  const flatbuffers::Vector<uint32_t> *new_max() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NEW_MAX);
  }
  const flatbuffers::Vector<uint32_t> *drop_max() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DROP_MAX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_MAX) &&
           verifier.VerifyVector(new_max()) &&
           VerifyOffset(verifier, VT_DROP_MAX) &&
           verifier.VerifyVector(drop_max()) &&
           verifier.EndTable();
  }
  SignalUpdateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SignalUpdateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SignalUpdate> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SignalUpdateBuilder {
  typedef SignalUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_max(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> new_max) {
    fbb_.AddOffset(SignalUpdate::VT_NEW_MAX, new_max);
  }
  void add_drop_max(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> drop_max) {
    fbb_.AddOffset(SignalUpdate::VT_DROP_MAX, drop_max);
  }
  explicit SignalUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SignalUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SignalUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<SignalUpdate> CreateSignalUpdate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> new_max = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> drop_max = 0) {
  SignalUpdateBuilder builder_(_fbb);
  builder_.add_drop_max(drop_max);
  builder_.add_new_max(new_max);
  return builder_.Finish();
}

inline flatbuffers::Offset<SignalUpdate> CreateSignalUpdateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *new_max = nullptr,
    const std::vector<uint32_t> *drop_max = nullptr) {
  auto new_max__ = new_max ? _fbb.CreateVector<uint32_t>(*new_max) : 0;
  auto drop_max__ = drop_max ? _fbb.CreateVector<uint32_t>(*drop_max) : 0;
  return rpc::CreateSignalUpdate(
      _fbb,
      new_max__,
      drop_max__);
}

flatbuffers::Offset<SignalUpdate> CreateSignalUpdate(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecutingMessageT : public flatbuffers::NativeTable {
  typedef ExecutingMessage TableType;
  int64_t id = 0;
  int32_t proc_id = 0;
  int32_t try_ = 0;
};

struct ExecutingMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecutingMessageT NativeTableType;
  typedef ExecutingMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PROC_ID = 6,
    VT_TRY_ = 8
  };
  int64_t id() const {
    return GetField<int64_t>(VT_ID, 0);
  }
  int32_t proc_id() const {
    return GetField<int32_t>(VT_PROC_ID, 0);
  }
  int32_t try_() const {
    return GetField<int32_t>(VT_TRY_, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ID, 8) &&
           VerifyField<int32_t>(verifier, VT_PROC_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TRY_, 4) &&
           verifier.EndTable();
  }
  ExecutingMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecutingMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecutingMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecutingMessageBuilder {
  typedef ExecutingMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(int64_t id) {
    fbb_.AddElement<int64_t>(ExecutingMessage::VT_ID, id, 0);
  }
  void add_proc_id(int32_t proc_id) {
    fbb_.AddElement<int32_t>(ExecutingMessage::VT_PROC_ID, proc_id, 0);
  }
  void add_try_(int32_t try_) {
    fbb_.AddElement<int32_t>(ExecutingMessage::VT_TRY_, try_, 0);
  }
  explicit ExecutingMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecutingMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecutingMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecutingMessage> CreateExecutingMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t id = 0,
    int32_t proc_id = 0,
    int32_t try_ = 0) {
  ExecutingMessageBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_try_(try_);
  builder_.add_proc_id(proc_id);
  return builder_.Finish();
}

flatbuffers::Offset<ExecutingMessage> CreateExecutingMessage(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatsMessageT : public flatbuffers::NativeTable {
  typedef StatsMessage TableType;
  int64_t noexec_count = 0;
  int64_t noexec_duration = 0;
};

struct StatsMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatsMessageT NativeTableType;
  typedef StatsMessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOEXEC_COUNT = 4,
    VT_NOEXEC_DURATION = 6
  };
  int64_t noexec_count() const {
    return GetField<int64_t>(VT_NOEXEC_COUNT, 0);
  }
  int64_t noexec_duration() const {
    return GetField<int64_t>(VT_NOEXEC_DURATION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NOEXEC_COUNT, 8) &&
           VerifyField<int64_t>(verifier, VT_NOEXEC_DURATION, 8) &&
           verifier.EndTable();
  }
  StatsMessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatsMessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatsMessage> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatsMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatsMessageBuilder {
  typedef StatsMessage Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_noexec_count(int64_t noexec_count) {
    fbb_.AddElement<int64_t>(StatsMessage::VT_NOEXEC_COUNT, noexec_count, 0);
  }
  void add_noexec_duration(int64_t noexec_duration) {
    fbb_.AddElement<int64_t>(StatsMessage::VT_NOEXEC_DURATION, noexec_duration, 0);
  }
  explicit StatsMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatsMessage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatsMessage>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatsMessage> CreateStatsMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t noexec_count = 0,
    int64_t noexec_duration = 0) {
  StatsMessageBuilder builder_(_fbb);
  builder_.add_noexec_duration(noexec_duration);
  builder_.add_noexec_count(noexec_count);
  return builder_.Finish();
}

flatbuffers::Offset<StatsMessage> CreateStatsMessage(flatbuffers::FlatBufferBuilder &_fbb, const StatsMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallInfoT : public flatbuffers::NativeTable {
  typedef CallInfo TableType;
  rpc::CallFlag flags = static_cast<rpc::CallFlag>(0);
  int32_t error = 0;
  std::vector<uint32_t> signal{};
  std::vector<uint32_t> cover{};
  std::vector<rpc::Comparison> comps{};
};

struct CallInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallInfoT NativeTableType;
  typedef CallInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_ERROR = 6,
    VT_SIGNAL = 8,
    VT_COVER = 10,
    VT_COMPS = 12
  };
  rpc::CallFlag flags() const {
    return static_cast<rpc::CallFlag>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  int32_t error() const {
    return GetField<int32_t>(VT_ERROR, 0);
  }
  const flatbuffers::Vector<uint32_t> *signal() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_SIGNAL);
  }
  const flatbuffers::Vector<uint32_t> *cover() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_COVER);
  }
  const flatbuffers::Vector<const rpc::Comparison *> *comps() const {
    return GetPointer<const flatbuffers::Vector<const rpc::Comparison *> *>(VT_COMPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS, 1) &&
           VerifyField<int32_t>(verifier, VT_ERROR, 4) &&
           VerifyOffset(verifier, VT_SIGNAL) &&
           verifier.VerifyVector(signal()) &&
           VerifyOffset(verifier, VT_COVER) &&
           verifier.VerifyVector(cover()) &&
           VerifyOffset(verifier, VT_COMPS) &&
           verifier.VerifyVector(comps()) &&
           verifier.EndTable();
  }
  CallInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CallInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallInfoBuilder {
  typedef CallInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(rpc::CallFlag flags) {
    fbb_.AddElement<uint8_t>(CallInfo::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_error(int32_t error) {
    fbb_.AddElement<int32_t>(CallInfo::VT_ERROR, error, 0);
  }
  void add_signal(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> signal) {
    fbb_.AddOffset(CallInfo::VT_SIGNAL, signal);
  }
  void add_cover(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cover) {
    fbb_.AddOffset(CallInfo::VT_COVER, cover);
  }
  void add_comps(flatbuffers::Offset<flatbuffers::Vector<const rpc::Comparison *>> comps) {
    fbb_.AddOffset(CallInfo::VT_COMPS, comps);
  }
  explicit CallInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CallInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallInfo> CreateCallInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> signal = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> cover = 0,
    flatbuffers::Offset<flatbuffers::Vector<const rpc::Comparison *>> comps = 0) {
  CallInfoBuilder builder_(_fbb);
  builder_.add_comps(comps);
  builder_.add_cover(cover);
  builder_.add_signal(signal);
  builder_.add_error(error);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<CallInfo> CreateCallInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    rpc::CallFlag flags = static_cast<rpc::CallFlag>(0),
    int32_t error = 0,
    const std::vector<uint32_t> *signal = nullptr,
    const std::vector<uint32_t> *cover = nullptr,
    const std::vector<rpc::Comparison> *comps = nullptr) {
  auto signal__ = signal ? _fbb.CreateVector<uint32_t>(*signal) : 0;
  auto cover__ = cover ? _fbb.CreateVector<uint32_t>(*cover) : 0;
  auto comps__ = comps ? _fbb.CreateVectorOfStructs<rpc::Comparison>(*comps) : 0;
  return rpc::CreateCallInfo(
      _fbb,
      flags,
      error,
      signal__,
      cover__,
      comps__);
}

flatbuffers::Offset<CallInfo> CreateCallInfo(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProgInfoT : public flatbuffers::NativeTable {
  typedef ProgInfo TableType;
  std::vector<std::unique_ptr<rpc::CallInfoT>> calls{};
  std::unique_ptr<rpc::CallInfoT> extra{};
  uint64_t elapsed = 0;
  uint64_t freshness = 0;
  ProgInfoT() = default;
  ProgInfoT(const ProgInfoT &o);
  ProgInfoT(ProgInfoT&&) FLATBUFFERS_NOEXCEPT = default;
  ProgInfoT &operator=(ProgInfoT o) FLATBUFFERS_NOEXCEPT;
};

struct ProgInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProgInfoT NativeTableType;
  typedef ProgInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CALLS = 4,
    VT_EXTRA = 6,
    VT_ELAPSED = 8,
    VT_FRESHNESS = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfo>> *calls() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfo>> *>(VT_CALLS);
  }
  const rpc::CallInfo *extra() const {
    return GetPointer<const rpc::CallInfo *>(VT_EXTRA);
  }
  uint64_t elapsed() const {
    return GetField<uint64_t>(VT_ELAPSED, 0);
  }
  uint64_t freshness() const {
    return GetField<uint64_t>(VT_FRESHNESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CALLS) &&
           verifier.VerifyVector(calls()) &&
           verifier.VerifyVectorOfTables(calls()) &&
           VerifyOffset(verifier, VT_EXTRA) &&
           verifier.VerifyTable(extra()) &&
           VerifyField<uint64_t>(verifier, VT_ELAPSED, 8) &&
           VerifyField<uint64_t>(verifier, VT_FRESHNESS, 8) &&
           verifier.EndTable();
  }
  ProgInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProgInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProgInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProgInfoBuilder {
  typedef ProgInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_calls(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfo>>> calls) {
    fbb_.AddOffset(ProgInfo::VT_CALLS, calls);
  }
  void add_extra(flatbuffers::Offset<rpc::CallInfo> extra) {
    fbb_.AddOffset(ProgInfo::VT_EXTRA, extra);
  }
  void add_elapsed(uint64_t elapsed) {
    fbb_.AddElement<uint64_t>(ProgInfo::VT_ELAPSED, elapsed, 0);
  }
  void add_freshness(uint64_t freshness) {
    fbb_.AddElement<uint64_t>(ProgInfo::VT_FRESHNESS, freshness, 0);
  }
  explicit ProgInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProgInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProgInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProgInfo> CreateProgInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<rpc::CallInfo>>> calls = 0,
    flatbuffers::Offset<rpc::CallInfo> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  ProgInfoBuilder builder_(_fbb);
  builder_.add_freshness(freshness);
  builder_.add_elapsed(elapsed);
  builder_.add_extra(extra);
  builder_.add_calls(calls);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgInfo> CreateProgInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<rpc::CallInfo>> *calls = nullptr,
    flatbuffers::Offset<rpc::CallInfo> extra = 0,
    uint64_t elapsed = 0,
    uint64_t freshness = 0) {
  auto calls__ = calls ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfo>>(*calls) : 0;
  return rpc::CreateProgInfo(
      _fbb,
      calls__,
      extra,
      elapsed,
      freshness);
}

flatbuffers::Offset<ProgInfo> CreateProgInfo(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExecResultT : public flatbuffers::NativeTable {
  typedef ExecResult TableType;
  std::unique_ptr<rpc::ExecutingMessageT> executing{};
  std::vector<uint8_t> output{};
  std::string error{};
  std::unique_ptr<rpc::ProgInfoT> info{};
  ExecResultT() = default;
  ExecResultT(const ExecResultT &o);
  ExecResultT(ExecResultT&&) FLATBUFFERS_NOEXCEPT = default;
  ExecResultT &operator=(ExecResultT o) FLATBUFFERS_NOEXCEPT;
};

struct ExecResult FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExecResultT NativeTableType;
  typedef ExecResultBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXECUTING = 4,
    VT_OUTPUT = 6,
    VT_ERROR = 8,
    VT_INFO = 10
  };
  const rpc::ExecutingMessage *executing() const {
    return GetPointer<const rpc::ExecutingMessage *>(VT_EXECUTING);
  }
  const flatbuffers::Vector<uint8_t> *output() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_OUTPUT);
  }
  const flatbuffers::String *error() const {
    return GetPointer<const flatbuffers::String *>(VT_ERROR);
  }
  const rpc::ProgInfo *info() const {
    return GetPointer<const rpc::ProgInfo *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXECUTING) &&
           verifier.VerifyTable(executing()) &&
           VerifyOffset(verifier, VT_OUTPUT) &&
           verifier.VerifyVector(output()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyString(error()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyTable(info()) &&
           verifier.EndTable();
  }
  ExecResultT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExecResultT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ExecResult> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExecResultBuilder {
  typedef ExecResult Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_executing(flatbuffers::Offset<rpc::ExecutingMessage> executing) {
    fbb_.AddOffset(ExecResult::VT_EXECUTING, executing);
  }
  void add_output(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output) {
    fbb_.AddOffset(ExecResult::VT_OUTPUT, output);
  }
  void add_error(flatbuffers::Offset<flatbuffers::String> error) {
    fbb_.AddOffset(ExecResult::VT_ERROR, error);
  }
  void add_info(flatbuffers::Offset<rpc::ProgInfo> info) {
    fbb_.AddOffset(ExecResult::VT_INFO, info);
  }
  explicit ExecResultBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExecResult> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecResult>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecResult> CreateExecResult(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<rpc::ExecutingMessage> executing = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> output = 0,
    flatbuffers::Offset<flatbuffers::String> error = 0,
    flatbuffers::Offset<rpc::ProgInfo> info = 0) {
  ExecResultBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_error(error);
  builder_.add_output(output);
  builder_.add_executing(executing);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecResult> CreateExecResultDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<rpc::ExecutingMessage> executing = 0,
    const std::vector<uint8_t> *output = nullptr,
    const char *error = nullptr,
    flatbuffers::Offset<rpc::ProgInfo> info = 0) {
  auto output__ = output ? _fbb.CreateVector<uint8_t>(*output) : 0;
  auto error__ = error ? _fbb.CreateString(error) : 0;
  return rpc::CreateExecResult(
      _fbb,
      executing,
      output__,
      error__,
      info);
}

flatbuffers::Offset<ExecResult> CreateExecResult(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ConnectRequestT *ConnectRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectRequestT>(new ConnectRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectRequest::UnPackTo(ConnectRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = arch(); if (_e) _o->arch = _e->str(); }
  { auto _e = git_revision(); if (_e) _o->git_revision = _e->str(); }
  { auto _e = syz_revision(); if (_e) _o->syz_revision = _e->str(); }
}

inline flatbuffers::Offset<ConnectRequest> ConnectRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectRequest> CreateConnectRequest(flatbuffers::FlatBufferBuilder &_fbb, const ConnectRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _arch = _o->arch.empty() ? 0 : _fbb.CreateString(_o->arch);
  auto _git_revision = _o->git_revision.empty() ? 0 : _fbb.CreateString(_o->git_revision);
  auto _syz_revision = _o->syz_revision.empty() ? 0 : _fbb.CreateString(_o->syz_revision);
  return rpc::CreateConnectRequest(
      _fbb,
      _name,
      _arch,
      _git_revision,
      _syz_revision);
}

inline ConnectReplyT *ConnectReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ConnectReplyT>(new ConnectReplyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ConnectReply::UnPackTo(ConnectReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leak_frames(); if (_e) { _o->leak_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->leak_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = race_frames(); if (_e) { _o->race_frames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->race_frames[_i] = _e->Get(_i)->str(); } } }
  { auto _e = features(); _o->features = _e; }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<ConnectReply> ConnectReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateConnectReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ConnectReply> CreateConnectReply(flatbuffers::FlatBufferBuilder &_fbb, const ConnectReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ConnectReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leak_frames = _o->leak_frames.size() ? _fbb.CreateVectorOfStrings(_o->leak_frames) : 0;
  auto _race_frames = _o->race_frames.size() ? _fbb.CreateVectorOfStrings(_o->race_frames) : 0;
  auto _features = _o->features;
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  auto _globs = _o->globs.size() ? _fbb.CreateVectorOfStrings(_o->globs) : 0;
  return rpc::CreateConnectReply(
      _fbb,
      _leak_frames,
      _race_frames,
      _features,
      _files,
      _globs);
}

inline InfoRequestT::InfoRequestT(const InfoRequestT &o)
      : error(o.error),
        features(o.features) {
  globs.reserve(o.globs.size());
  for (const auto &globs_ : o.globs) { globs.emplace_back((globs_) ? new rpc::GlobInfoT(*globs_) : nullptr); }
  files.reserve(o.files.size());
  for (const auto &files_ : o.files) { files.emplace_back((files_) ? new rpc::FileInfoT(*files_) : nullptr); }
}

inline InfoRequestT &InfoRequestT::operator=(InfoRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(error, o.error);
  std::swap(features, o.features);
  std::swap(globs, o.globs);
  std::swap(files, o.files);
  return *this;
}

inline InfoRequestT *InfoRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoRequestT>(new InfoRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoRequest::UnPackTo(InfoRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = features(); _o->features = _e; }
  { auto _e = globs(); if (_e) { _o->globs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->globs[_i] = std::unique_ptr<rpc::GlobInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = std::unique_ptr<rpc::FileInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<InfoRequest> InfoRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoRequest> CreateInfoRequest(flatbuffers::FlatBufferBuilder &_fbb, const InfoRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _features = _o->features;
  auto _globs = _o->globs.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::GlobInfo>> (_o->globs.size(), [](size_t i, _VectorArgs *__va) { return CreateGlobInfo(*__va->__fbb, __va->__o->globs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _files = _o->files.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::FileInfo>> (_o->files.size(), [](size_t i, _VectorArgs *__va) { return CreateFileInfo(*__va->__fbb, __va->__o->files[i].get(), __va->__rehasher); }, &_va ) : 0;
  return rpc::CreateInfoRequest(
      _fbb,
      _error,
      _features,
      _globs,
      _files);
}

inline InfoReplyT *InfoReply::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<InfoReplyT>(new InfoReplyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void InfoReply::UnPackTo(InfoReplyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cover_filter(); if (_e) { _o->cover_filter.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cover_filter[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<InfoReply> InfoReply::Pack(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInfoReply(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<InfoReply> CreateInfoReply(flatbuffers::FlatBufferBuilder &_fbb, const InfoReplyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const InfoReplyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cover_filter = _o->cover_filter.size() ? _fbb.CreateVector(_o->cover_filter) : 0;
  return rpc::CreateInfoReply(
      _fbb,
      _cover_filter);
}

inline FileInfoT *FileInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FileInfoT>(new FileInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FileInfo::UnPackTo(FileInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = exists(); _o->exists = _e; }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline flatbuffers::Offset<FileInfo> FileInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFileInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FileInfo> CreateFileInfo(flatbuffers::FlatBufferBuilder &_fbb, const FileInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FileInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _exists = _o->exists;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return rpc::CreateFileInfo(
      _fbb,
      _name,
      _exists,
      _error,
      _data);
}

inline GlobInfoT *GlobInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GlobInfoT>(new GlobInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GlobInfo::UnPackTo(GlobInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = files(); if (_e) { _o->files.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->files[_i] = _e->Get(_i)->str(); } } }
}

inline flatbuffers::Offset<GlobInfo> GlobInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGlobInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GlobInfo> CreateGlobInfo(flatbuffers::FlatBufferBuilder &_fbb, const GlobInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GlobInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _files = _o->files.size() ? _fbb.CreateVectorOfStrings(_o->files) : 0;
  return rpc::CreateGlobInfo(
      _fbb,
      _name,
      _files);
}

inline HostMessageT *HostMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<HostMessageT>(new HostMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void HostMessage::UnPackTo(HostMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::HostMessagesUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<HostMessage> HostMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHostMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HostMessage> CreateHostMessage(flatbuffers::FlatBufferBuilder &_fbb, const HostMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HostMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateHostMessage(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecutorMessageT *ExecutorMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutorMessageT>(new ExecutorMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutorMessage::UnPackTo(ExecutorMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = msg_type(); _o->msg.type = _e; }
  { auto _e = msg(); if (_e) _o->msg.value = rpc::ExecutorMessagesUnion::UnPack(_e, msg_type(), _resolver); }
}

inline flatbuffers::Offset<ExecutorMessage> ExecutorMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutorMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutorMessage> CreateExecutorMessage(flatbuffers::FlatBufferBuilder &_fbb, const ExecutorMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutorMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _msg_type = _o->msg.type;
  auto _msg = _o->msg.Pack(_fbb);
  return rpc::CreateExecutorMessage(
      _fbb,
      _msg_type,
      _msg);
}

inline ExecRequestT *ExecRequest::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecRequestT>(new ExecRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecRequest::UnPackTo(ExecRequestT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = prog_data(); if (_e) { _o->prog_data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->prog_data.begin()); } }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = exec_env(); _o->exec_env = _e; }
  { auto _e = exec_flags(); _o->exec_flags = _e; }
  { auto _e = sandbox_arg(); _o->sandbox_arg = _e; }
  { auto _e = signal_filter(); if (_e) { _o->signal_filter.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal_filter[_i] = _e->Get(_i); } } }
  { auto _e = signal_filter_call(); _o->signal_filter_call = _e; }
  { auto _e = repeat(); _o->repeat = _e; }
}

inline flatbuffers::Offset<ExecRequest> ExecRequest::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecRequest(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecRequest> CreateExecRequest(flatbuffers::FlatBufferBuilder &_fbb, const ExecRequestT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecRequestT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _prog_data = _o->prog_data.size() ? _fbb.CreateVector(_o->prog_data) : 0;
  auto _flags = _o->flags;
  auto _exec_env = _o->exec_env;
  auto _exec_flags = _o->exec_flags;
  auto _sandbox_arg = _o->sandbox_arg;
  auto _signal_filter = _o->signal_filter.size() ? _fbb.CreateVector(_o->signal_filter) : 0;
  auto _signal_filter_call = _o->signal_filter_call;
  auto _repeat = _o->repeat;
  return rpc::CreateExecRequest(
      _fbb,
      _id,
      _prog_data,
      _flags,
      _exec_env,
      _exec_flags,
      _sandbox_arg,
      _signal_filter,
      _signal_filter_call,
      _repeat);
}

inline SignalUpdateT *SignalUpdate::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SignalUpdateT>(new SignalUpdateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SignalUpdate::UnPackTo(SignalUpdateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = new_max(); if (_e) { _o->new_max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->new_max[_i] = _e->Get(_i); } } }
  { auto _e = drop_max(); if (_e) { _o->drop_max.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->drop_max[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<SignalUpdate> SignalUpdate::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSignalUpdate(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SignalUpdate> CreateSignalUpdate(flatbuffers::FlatBufferBuilder &_fbb, const SignalUpdateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SignalUpdateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _new_max = _o->new_max.size() ? _fbb.CreateVector(_o->new_max) : 0;
  auto _drop_max = _o->drop_max.size() ? _fbb.CreateVector(_o->drop_max) : 0;
  return rpc::CreateSignalUpdate(
      _fbb,
      _new_max,
      _drop_max);
}

inline ExecutingMessageT *ExecutingMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecutingMessageT>(new ExecutingMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecutingMessage::UnPackTo(ExecutingMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); _o->id = _e; }
  { auto _e = proc_id(); _o->proc_id = _e; }
  { auto _e = try_(); _o->try_ = _e; }
}

inline flatbuffers::Offset<ExecutingMessage> ExecutingMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecutingMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecutingMessage> CreateExecutingMessage(flatbuffers::FlatBufferBuilder &_fbb, const ExecutingMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecutingMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id;
  auto _proc_id = _o->proc_id;
  auto _try_ = _o->try_;
  return rpc::CreateExecutingMessage(
      _fbb,
      _id,
      _proc_id,
      _try_);
}

inline StatsMessageT *StatsMessage::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatsMessageT>(new StatsMessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatsMessage::UnPackTo(StatsMessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = noexec_count(); _o->noexec_count = _e; }
  { auto _e = noexec_duration(); _o->noexec_duration = _e; }
}

inline flatbuffers::Offset<StatsMessage> StatsMessage::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatsMessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatsMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatsMessage> CreateStatsMessage(flatbuffers::FlatBufferBuilder &_fbb, const StatsMessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatsMessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _noexec_count = _o->noexec_count;
  auto _noexec_duration = _o->noexec_duration;
  return rpc::CreateStatsMessage(
      _fbb,
      _noexec_count,
      _noexec_duration);
}

inline CallInfoT *CallInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CallInfoT>(new CallInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallInfo::UnPackTo(CallInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = error(); _o->error = _e; }
  { auto _e = signal(); if (_e) { _o->signal.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->signal[_i] = _e->Get(_i); } } }
  { auto _e = cover(); if (_e) { _o->cover.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cover[_i] = _e->Get(_i); } } }
  { auto _e = comps(); if (_e) { _o->comps.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->comps[_i] = *_e->Get(_i); } } }
}

inline flatbuffers::Offset<CallInfo> CallInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CallInfo> CreateCallInfo(flatbuffers::FlatBufferBuilder &_fbb, const CallInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CallInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _error = _o->error;
  auto _signal = _o->signal.size() ? _fbb.CreateVector(_o->signal) : 0;
  auto _cover = _o->cover.size() ? _fbb.CreateVector(_o->cover) : 0;
  auto _comps = _o->comps.size() ? _fbb.CreateVectorOfStructs(_o->comps) : 0;
  return rpc::CreateCallInfo(
      _fbb,
      _flags,
      _error,
      _signal,
      _cover,
      _comps);
}

inline ProgInfoT::ProgInfoT(const ProgInfoT &o)
      : extra((o.extra) ? new rpc::CallInfoT(*o.extra) : nullptr),
        elapsed(o.elapsed),
        freshness(o.freshness) {
  calls.reserve(o.calls.size());
  for (const auto &calls_ : o.calls) { calls.emplace_back((calls_) ? new rpc::CallInfoT(*calls_) : nullptr); }
}

inline ProgInfoT &ProgInfoT::operator=(ProgInfoT o) FLATBUFFERS_NOEXCEPT {
  std::swap(calls, o.calls);
  std::swap(extra, o.extra);
  std::swap(elapsed, o.elapsed);
  std::swap(freshness, o.freshness);
  return *this;
}

inline ProgInfoT *ProgInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProgInfoT>(new ProgInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProgInfo::UnPackTo(ProgInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = calls(); if (_e) { _o->calls.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->calls[_i] = std::unique_ptr<rpc::CallInfoT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = extra(); if (_e) _o->extra = std::unique_ptr<rpc::CallInfoT>(_e->UnPack(_resolver)); }
  { auto _e = elapsed(); _o->elapsed = _e; }
  { auto _e = freshness(); _o->freshness = _e; }
}

inline flatbuffers::Offset<ProgInfo> ProgInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProgInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProgInfo> CreateProgInfo(flatbuffers::FlatBufferBuilder &_fbb, const ProgInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProgInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _calls = _o->calls.size() ? _fbb.CreateVector<flatbuffers::Offset<rpc::CallInfo>> (_o->calls.size(), [](size_t i, _VectorArgs *__va) { return CreateCallInfo(*__va->__fbb, __va->__o->calls[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _extra = _o->extra ? CreateCallInfo(_fbb, _o->extra.get(), _rehasher) : 0;
  auto _elapsed = _o->elapsed;
  auto _freshness = _o->freshness;
  return rpc::CreateProgInfo(
      _fbb,
      _calls,
      _extra,
      _elapsed,
      _freshness);
}

inline ExecResultT::ExecResultT(const ExecResultT &o)
      : executing((o.executing) ? new rpc::ExecutingMessageT(*o.executing) : nullptr),
        output(o.output),
        error(o.error),
        info((o.info) ? new rpc::ProgInfoT(*o.info) : nullptr) {
}

inline ExecResultT &ExecResultT::operator=(ExecResultT o) FLATBUFFERS_NOEXCEPT {
  std::swap(executing, o.executing);
  std::swap(output, o.output);
  std::swap(error, o.error);
  std::swap(info, o.info);
  return *this;
}

inline ExecResultT *ExecResult::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExecResultT>(new ExecResultT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExecResult::UnPackTo(ExecResultT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = executing(); if (_e) _o->executing = std::unique_ptr<rpc::ExecutingMessageT>(_e->UnPack(_resolver)); }
  { auto _e = output(); if (_e) { _o->output.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->output.begin()); } }
  { auto _e = error(); if (_e) _o->error = _e->str(); }
  { auto _e = info(); if (_e) _o->info = std::unique_ptr<rpc::ProgInfoT>(_e->UnPack(_resolver)); }
}

inline flatbuffers::Offset<ExecResult> ExecResult::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExecResult(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ExecResult> CreateExecResult(flatbuffers::FlatBufferBuilder &_fbb, const ExecResultT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExecResultT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _executing = _o->executing ? CreateExecutingMessage(_fbb, _o->executing.get(), _rehasher) : 0;
  auto _output = _o->output.size() ? _fbb.CreateVector(_o->output) : 0;
  auto _error = _o->error.empty() ? 0 : _fbb.CreateString(_o->error);
  auto _info = _o->info ? CreateProgInfo(_fbb, _o->info.get(), _rehasher) : 0;
  return rpc::CreateExecResult(
      _fbb,
      _executing,
      _output,
      _error,
      _info);
}

inline bool VerifyHostMessages(flatbuffers::Verifier &verifier, const void *obj, HostMessages type) {
  switch (type) {
    case HostMessages::NONE: {
      return true;
    }
    case HostMessages::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case HostMessages::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyHostMessagesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<HostMessages> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyHostMessages(
        verifier,  values->Get(i), types->GetEnum<HostMessages>(i))) {
      return false;
    }
  }
  return true;
}

inline void *HostMessagesUnion::UnPack(const void *obj, HostMessages type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case HostMessages::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case HostMessages::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdate *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> HostMessagesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case HostMessages::ExecRequest: {
      auto ptr = reinterpret_cast<const rpc::ExecRequestT *>(value);
      return CreateExecRequest(_fbb, ptr, _rehasher).Union();
    }
    case HostMessages::SignalUpdate: {
      auto ptr = reinterpret_cast<const rpc::SignalUpdateT *>(value);
      return CreateSignalUpdate(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline HostMessagesUnion::HostMessagesUnion(const HostMessagesUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case HostMessages::ExecRequest: {
      value = new rpc::ExecRequestT(*reinterpret_cast<rpc::ExecRequestT *>(u.value));
      break;
    }
    case HostMessages::SignalUpdate: {
      value = new rpc::SignalUpdateT(*reinterpret_cast<rpc::SignalUpdateT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void HostMessagesUnion::Reset() {
  switch (type) {
    case HostMessages::ExecRequest: {
      auto ptr = reinterpret_cast<rpc::ExecRequestT *>(value);
      delete ptr;
      break;
    }
    case HostMessages::SignalUpdate: {
      auto ptr = reinterpret_cast<rpc::SignalUpdateT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = HostMessages::NONE;
}

inline bool VerifyExecutorMessages(flatbuffers::Verifier &verifier, const void *obj, ExecutorMessages type) {
  switch (type) {
    case ExecutorMessages::NONE: {
      return true;
    }
    case ExecutorMessages::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResult *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExecutorMessages::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ExecutorMessages::Stats: {
      auto ptr = reinterpret_cast<const rpc::StatsMessage *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyExecutorMessagesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ExecutorMessages> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyExecutorMessages(
        verifier,  values->Get(i), types->GetEnum<ExecutorMessages>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ExecutorMessagesUnion::UnPack(const void *obj, ExecutorMessages type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ExecutorMessages::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResult *>(obj);
      return ptr->UnPack(resolver);
    }
    case ExecutorMessages::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    case ExecutorMessages::Stats: {
      auto ptr = reinterpret_cast<const rpc::StatsMessage *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> ExecutorMessagesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ExecutorMessages::ExecResult: {
      auto ptr = reinterpret_cast<const rpc::ExecResultT *>(value);
      return CreateExecResult(_fbb, ptr, _rehasher).Union();
    }
    case ExecutorMessages::Executing: {
      auto ptr = reinterpret_cast<const rpc::ExecutingMessageT *>(value);
      return CreateExecutingMessage(_fbb, ptr, _rehasher).Union();
    }
    case ExecutorMessages::Stats: {
      auto ptr = reinterpret_cast<const rpc::StatsMessageT *>(value);
      return CreateStatsMessage(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ExecutorMessagesUnion::ExecutorMessagesUnion(const ExecutorMessagesUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ExecutorMessages::ExecResult: {
      value = new rpc::ExecResultT(*reinterpret_cast<rpc::ExecResultT *>(u.value));
      break;
    }
    case ExecutorMessages::Executing: {
      value = new rpc::ExecutingMessageT(*reinterpret_cast<rpc::ExecutingMessageT *>(u.value));
      break;
    }
    case ExecutorMessages::Stats: {
      value = new rpc::StatsMessageT(*reinterpret_cast<rpc::StatsMessageT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ExecutorMessagesUnion::Reset() {
  switch (type) {
    case ExecutorMessages::ExecResult: {
      auto ptr = reinterpret_cast<rpc::ExecResultT *>(value);
      delete ptr;
      break;
    }
    case ExecutorMessages::Executing: {
      auto ptr = reinterpret_cast<rpc::ExecutingMessageT *>(value);
      delete ptr;
      break;
    }
    case ExecutorMessages::Stats: {
      auto ptr = reinterpret_cast<rpc::StatsMessageT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ExecutorMessages::NONE;
}

}  // namespace rpc

#endif  // FLATBUFFERS_GENERATED_FLATRPC_RPC_H_
