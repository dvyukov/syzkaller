// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package flatrpc

import (
	"strconv"

	flatbuffers "github.com/google/flatbuffers/go"
)

type Feature uint64

const (
	FeatureCoverage         Feature = 1
	FeatureComparisons      Feature = 2
	FeatureExtraCoverage    Feature = 4
	FeatureDelayKcovMmap    Feature = 8
	FeatureSandboxSetuid    Feature = 16
	FeatureSandboxNamespace Feature = 32
	FeatureSandboxAndroid   Feature = 64
	FeatureFault            Feature = 128
	FeatureLeak             Feature = 256
	FeatureNetInjection     Feature = 512
	FeatureNetDevices       Feature = 1024
	FeatureKCSAN            Feature = 2048
	FeatureDevlinkPCI       Feature = 4096
	FeatureNicVF            Feature = 8192
	FeatureUSBEmulation     Feature = 16384
	FeatureVhciInjection    Feature = 32768
	FeatureWifiEmulation    Feature = 65536
	FeatureLRWPANEmulation  Feature = 131072
	FeatureBinFmtMisc       Feature = 262144
	FeatureSwap             Feature = 524288
)

var EnumNamesFeature = map[Feature]string{
	FeatureCoverage:         "Coverage",
	FeatureComparisons:      "Comparisons",
	FeatureExtraCoverage:    "ExtraCoverage",
	FeatureDelayKcovMmap:    "DelayKcovMmap",
	FeatureSandboxSetuid:    "SandboxSetuid",
	FeatureSandboxNamespace: "SandboxNamespace",
	FeatureSandboxAndroid:   "SandboxAndroid",
	FeatureFault:            "Fault",
	FeatureLeak:             "Leak",
	FeatureNetInjection:     "NetInjection",
	FeatureNetDevices:       "NetDevices",
	FeatureKCSAN:            "KCSAN",
	FeatureDevlinkPCI:       "DevlinkPCI",
	FeatureNicVF:            "NicVF",
	FeatureUSBEmulation:     "USBEmulation",
	FeatureVhciInjection:    "VhciInjection",
	FeatureWifiEmulation:    "WifiEmulation",
	FeatureLRWPANEmulation:  "LRWPANEmulation",
	FeatureBinFmtMisc:       "BinFmtMisc",
	FeatureSwap:             "Swap",
}

var EnumValuesFeature = map[string]Feature{
	"Coverage":         FeatureCoverage,
	"Comparisons":      FeatureComparisons,
	"ExtraCoverage":    FeatureExtraCoverage,
	"DelayKcovMmap":    FeatureDelayKcovMmap,
	"SandboxSetuid":    FeatureSandboxSetuid,
	"SandboxNamespace": FeatureSandboxNamespace,
	"SandboxAndroid":   FeatureSandboxAndroid,
	"Fault":            FeatureFault,
	"Leak":             FeatureLeak,
	"NetInjection":     FeatureNetInjection,
	"NetDevices":       FeatureNetDevices,
	"KCSAN":            FeatureKCSAN,
	"DevlinkPCI":       FeatureDevlinkPCI,
	"NicVF":            FeatureNicVF,
	"USBEmulation":     FeatureUSBEmulation,
	"VhciInjection":    FeatureVhciInjection,
	"WifiEmulation":    FeatureWifiEmulation,
	"LRWPANEmulation":  FeatureLRWPANEmulation,
	"BinFmtMisc":       FeatureBinFmtMisc,
	"Swap":             FeatureSwap,
}

func (v Feature) String() string {
	if s, ok := EnumNamesFeature[v]; ok {
		return s
	}
	return "Feature(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessages byte

const (
	HostMessagesNONE         HostMessages = 0
	HostMessagesExecRequest  HostMessages = 1
	HostMessagesSignalUpdate HostMessages = 2
)

var EnumNamesHostMessages = map[HostMessages]string{
	HostMessagesNONE:         "NONE",
	HostMessagesExecRequest:  "ExecRequest",
	HostMessagesSignalUpdate: "SignalUpdate",
}

var EnumValuesHostMessages = map[string]HostMessages{
	"NONE":         HostMessagesNONE,
	"ExecRequest":  HostMessagesExecRequest,
	"SignalUpdate": HostMessagesSignalUpdate,
}

func (v HostMessages) String() string {
	if s, ok := EnumNamesHostMessages[v]; ok {
		return s
	}
	return "HostMessages(" + strconv.FormatInt(int64(v), 10) + ")"
}

type HostMessagesT struct {
	Type  HostMessages
	Value interface{}
}

func (t *HostMessagesT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case HostMessagesExecRequest:
		return t.Value.(*ExecRequestT).Pack(builder)
	case HostMessagesSignalUpdate:
		return t.Value.(*SignalUpdateT).Pack(builder)
	}
	return 0
}

func (rcv HostMessages) UnPack(table flatbuffers.Table) *HostMessagesT {
	switch rcv {
	case HostMessagesExecRequest:
		x := ExecRequest{_tab: table}
		return &HostMessagesT{Type: HostMessagesExecRequest, Value: x.UnPack()}
	case HostMessagesSignalUpdate:
		x := SignalUpdate{_tab: table}
		return &HostMessagesT{Type: HostMessagesSignalUpdate, Value: x.UnPack()}
	}
	return nil
}

type ExecutorMessages byte

const (
	ExecutorMessagesNONE       ExecutorMessages = 0
	ExecutorMessagesExecResult ExecutorMessages = 1
	ExecutorMessagesExecuting  ExecutorMessages = 2
	ExecutorMessagesStats      ExecutorMessages = 3
)

var EnumNamesExecutorMessages = map[ExecutorMessages]string{
	ExecutorMessagesNONE:       "NONE",
	ExecutorMessagesExecResult: "ExecResult",
	ExecutorMessagesExecuting:  "Executing",
	ExecutorMessagesStats:      "Stats",
}

var EnumValuesExecutorMessages = map[string]ExecutorMessages{
	"NONE":       ExecutorMessagesNONE,
	"ExecResult": ExecutorMessagesExecResult,
	"Executing":  ExecutorMessagesExecuting,
	"Stats":      ExecutorMessagesStats,
}

func (v ExecutorMessages) String() string {
	if s, ok := EnumNamesExecutorMessages[v]; ok {
		return s
	}
	return "ExecutorMessages(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecutorMessagesT struct {
	Type  ExecutorMessages
	Value interface{}
}

func (t *ExecutorMessagesT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case ExecutorMessagesExecResult:
		return t.Value.(*ExecResultT).Pack(builder)
	case ExecutorMessagesExecuting:
		return t.Value.(*ExecutingMessageT).Pack(builder)
	case ExecutorMessagesStats:
		return t.Value.(*StatsMessageT).Pack(builder)
	}
	return 0
}

func (rcv ExecutorMessages) UnPack(table flatbuffers.Table) *ExecutorMessagesT {
	switch rcv {
	case ExecutorMessagesExecResult:
		x := ExecResult{_tab: table}
		return &ExecutorMessagesT{Type: ExecutorMessagesExecResult, Value: x.UnPack()}
	case ExecutorMessagesExecuting:
		x := ExecutingMessage{_tab: table}
		return &ExecutorMessagesT{Type: ExecutorMessagesExecuting, Value: x.UnPack()}
	case ExecutorMessagesStats:
		x := StatsMessage{_tab: table}
		return &ExecutorMessagesT{Type: ExecutorMessagesStats, Value: x.UnPack()}
	}
	return nil
}

type RequestFlag uint64

const (
	RequestFlagIsBinary     RequestFlag = 1
	RequestFlagNewSignal    RequestFlag = 2
	RequestFlagResetState   RequestFlag = 4
	RequestFlagReturnOutput RequestFlag = 8
	RequestFlagReturnError  RequestFlag = 16
)

var EnumNamesRequestFlag = map[RequestFlag]string{
	RequestFlagIsBinary:     "IsBinary",
	RequestFlagNewSignal:    "NewSignal",
	RequestFlagResetState:   "ResetState",
	RequestFlagReturnOutput: "ReturnOutput",
	RequestFlagReturnError:  "ReturnError",
}

var EnumValuesRequestFlag = map[string]RequestFlag{
	"IsBinary":     RequestFlagIsBinary,
	"NewSignal":    RequestFlagNewSignal,
	"ResetState":   RequestFlagResetState,
	"ReturnOutput": RequestFlagReturnOutput,
	"ReturnError":  RequestFlagReturnError,
}

func (v RequestFlag) String() string {
	if s, ok := EnumNamesRequestFlag[v]; ok {
		return s
	}
	return "RequestFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecEnv uint64

const (
	ExecEnvDebug               ExecEnv = 1
	ExecEnvSignal              ExecEnv = 2
	ExecEnvSandboxSetuid       ExecEnv = 4
	ExecEnvSandboxNamespace    ExecEnv = 8
	ExecEnvSandboxAndroid      ExecEnv = 16
	ExecEnvExtraCover          ExecEnv = 32
	ExecEnvEnableTun           ExecEnv = 64
	ExecEnvEnableNetDev        ExecEnv = 128
	ExecEnvEnableNetReset      ExecEnv = 256
	ExecEnvEnableCgroups       ExecEnv = 512
	ExecEnvEnableCloseFds      ExecEnv = 1024
	ExecEnvEnableDevlinkPCI    ExecEnv = 2048
	ExecEnvEnableVhciInjection ExecEnv = 4096
	ExecEnvEnableWifi          ExecEnv = 8192
	ExecEnvDelayKcovMmap       ExecEnv = 16384
	ExecEnvEnableNicVF         ExecEnv = 32768
)

var EnumNamesExecEnv = map[ExecEnv]string{
	ExecEnvDebug:               "Debug",
	ExecEnvSignal:              "Signal",
	ExecEnvSandboxSetuid:       "SandboxSetuid",
	ExecEnvSandboxNamespace:    "SandboxNamespace",
	ExecEnvSandboxAndroid:      "SandboxAndroid",
	ExecEnvExtraCover:          "ExtraCover",
	ExecEnvEnableTun:           "EnableTun",
	ExecEnvEnableNetDev:        "EnableNetDev",
	ExecEnvEnableNetReset:      "EnableNetReset",
	ExecEnvEnableCgroups:       "EnableCgroups",
	ExecEnvEnableCloseFds:      "EnableCloseFds",
	ExecEnvEnableDevlinkPCI:    "EnableDevlinkPCI",
	ExecEnvEnableVhciInjection: "EnableVhciInjection",
	ExecEnvEnableWifi:          "EnableWifi",
	ExecEnvDelayKcovMmap:       "DelayKcovMmap",
	ExecEnvEnableNicVF:         "EnableNicVF",
}

var EnumValuesExecEnv = map[string]ExecEnv{
	"Debug":               ExecEnvDebug,
	"Signal":              ExecEnvSignal,
	"SandboxSetuid":       ExecEnvSandboxSetuid,
	"SandboxNamespace":    ExecEnvSandboxNamespace,
	"SandboxAndroid":      ExecEnvSandboxAndroid,
	"ExtraCover":          ExecEnvExtraCover,
	"EnableTun":           ExecEnvEnableTun,
	"EnableNetDev":        ExecEnvEnableNetDev,
	"EnableNetReset":      ExecEnvEnableNetReset,
	"EnableCgroups":       ExecEnvEnableCgroups,
	"EnableCloseFds":      ExecEnvEnableCloseFds,
	"EnableDevlinkPCI":    ExecEnvEnableDevlinkPCI,
	"EnableVhciInjection": ExecEnvEnableVhciInjection,
	"EnableWifi":          ExecEnvEnableWifi,
	"DelayKcovMmap":       ExecEnvDelayKcovMmap,
	"EnableNicVF":         ExecEnvEnableNicVF,
}

func (v ExecEnv) String() string {
	if s, ok := EnumNamesExecEnv[v]; ok {
		return s
	}
	return "ExecEnv(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ExecFlag uint64

const (
	ExecFlagCollectSignal ExecFlag = 1
	ExecFlagCollectCover  ExecFlag = 2
	ExecFlagDedupCover    ExecFlag = 4
	ExecFlagCollectComps  ExecFlag = 8
	ExecFlagThreaded      ExecFlag = 16
	ExecFlagCoverFilter   ExecFlag = 32
)

var EnumNamesExecFlag = map[ExecFlag]string{
	ExecFlagCollectSignal: "CollectSignal",
	ExecFlagCollectCover:  "CollectCover",
	ExecFlagDedupCover:    "DedupCover",
	ExecFlagCollectComps:  "CollectComps",
	ExecFlagThreaded:      "Threaded",
	ExecFlagCoverFilter:   "CoverFilter",
}

var EnumValuesExecFlag = map[string]ExecFlag{
	"CollectSignal": ExecFlagCollectSignal,
	"CollectCover":  ExecFlagCollectCover,
	"DedupCover":    ExecFlagDedupCover,
	"CollectComps":  ExecFlagCollectComps,
	"Threaded":      ExecFlagThreaded,
	"CoverFilter":   ExecFlagCoverFilter,
}

func (v ExecFlag) String() string {
	if s, ok := EnumNamesExecFlag[v]; ok {
		return s
	}
	return "ExecFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type CallFlag byte

const (
	CallFlagExecuted      CallFlag = 1
	CallFlagFinished      CallFlag = 2
	CallFlagBlocked       CallFlag = 4
	CallFlagFaultInjected CallFlag = 8
)

var EnumNamesCallFlag = map[CallFlag]string{
	CallFlagExecuted:      "Executed",
	CallFlagFinished:      "Finished",
	CallFlagBlocked:       "Blocked",
	CallFlagFaultInjected: "FaultInjected",
}

var EnumValuesCallFlag = map[string]CallFlag{
	"Executed":      CallFlagExecuted,
	"Finished":      CallFlagFinished,
	"Blocked":       CallFlagBlocked,
	"FaultInjected": CallFlagFaultInjected,
}

func (v CallFlag) String() string {
	if s, ok := EnumNamesCallFlag[v]; ok {
		return s
	}
	return "CallFlag(" + strconv.FormatInt(int64(v), 10) + ")"
}

type ConnectRequestT struct {
	Name        string `json:"name"`
	Arch        string `json:"arch"`
	GitRevision string `json:"git_revision"`
	SyzRevision string `json:"syz_revision"`
}

func (t *ConnectRequestT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	archOffset := builder.CreateString(t.Arch)
	gitRevisionOffset := builder.CreateString(t.GitRevision)
	syzRevisionOffset := builder.CreateString(t.SyzRevision)
	ConnectRequestStart(builder)
	ConnectRequestAddName(builder, nameOffset)
	ConnectRequestAddArch(builder, archOffset)
	ConnectRequestAddGitRevision(builder, gitRevisionOffset)
	ConnectRequestAddSyzRevision(builder, syzRevisionOffset)
	return ConnectRequestEnd(builder)
}

func (rcv *ConnectRequest) UnPackTo(t *ConnectRequestT) {
	t.Name = string(rcv.Name())
	t.Arch = string(rcv.Arch())
	t.GitRevision = string(rcv.GitRevision())
	t.SyzRevision = string(rcv.SyzRevision())
}

func (rcv *ConnectRequest) UnPack() *ConnectRequestT {
	if rcv == nil {
		return nil
	}
	t := &ConnectRequestT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectRequest(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectRequest{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectRequest(buf []byte, offset flatbuffers.UOffsetT) *ConnectRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectRequest) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequest) Arch() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequest) GitRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ConnectRequest) SyzRevision() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func ConnectRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ConnectRequestAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func ConnectRequestAddArch(builder *flatbuffers.Builder, arch flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(arch), 0)
}
func ConnectRequestAddGitRevision(builder *flatbuffers.Builder, gitRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(gitRevision), 0)
}
func ConnectRequestAddSyzRevision(builder *flatbuffers.Builder, syzRevision flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(syzRevision), 0)
}
func ConnectRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ConnectReplyT struct {
	LeakFrames []string `json:"leak_frames"`
	RaceFrames []string `json:"race_frames"`
	Features   Feature  `json:"features"`
	Files      []string `json:"files"`
	Globs      []string `json:"globs"`
}

func (t *ConnectReplyT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	leakFramesOffset := flatbuffers.UOffsetT(0)
	if t.LeakFrames != nil {
		leakFramesLength := len(t.LeakFrames)
		leakFramesOffsets := make([]flatbuffers.UOffsetT, leakFramesLength)
		for j := 0; j < leakFramesLength; j++ {
			leakFramesOffsets[j] = builder.CreateString(t.LeakFrames[j])
		}
		ConnectReplyStartLeakFramesVector(builder, leakFramesLength)
		for j := leakFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(leakFramesOffsets[j])
		}
		leakFramesOffset = builder.EndVector(leakFramesLength)
	}
	raceFramesOffset := flatbuffers.UOffsetT(0)
	if t.RaceFrames != nil {
		raceFramesLength := len(t.RaceFrames)
		raceFramesOffsets := make([]flatbuffers.UOffsetT, raceFramesLength)
		for j := 0; j < raceFramesLength; j++ {
			raceFramesOffsets[j] = builder.CreateString(t.RaceFrames[j])
		}
		ConnectReplyStartRaceFramesVector(builder, raceFramesLength)
		for j := raceFramesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(raceFramesOffsets[j])
		}
		raceFramesOffset = builder.EndVector(raceFramesLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		ConnectReplyStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = builder.CreateString(t.Globs[j])
		}
		ConnectReplyStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	ConnectReplyStart(builder)
	ConnectReplyAddLeakFrames(builder, leakFramesOffset)
	ConnectReplyAddRaceFrames(builder, raceFramesOffset)
	ConnectReplyAddFeatures(builder, t.Features)
	ConnectReplyAddFiles(builder, filesOffset)
	ConnectReplyAddGlobs(builder, globsOffset)
	return ConnectReplyEnd(builder)
}

func (rcv *ConnectReply) UnPackTo(t *ConnectReplyT) {
	leakFramesLength := rcv.LeakFramesLength()
	t.LeakFrames = make([]string, leakFramesLength)
	for j := 0; j < leakFramesLength; j++ {
		t.LeakFrames[j] = string(rcv.LeakFrames(j))
	}
	raceFramesLength := rcv.RaceFramesLength()
	t.RaceFrames = make([]string, raceFramesLength)
	for j := 0; j < raceFramesLength; j++ {
		t.RaceFrames[j] = string(rcv.RaceFrames(j))
	}
	t.Features = rcv.Features()
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
	globsLength := rcv.GlobsLength()
	t.Globs = make([]string, globsLength)
	for j := 0; j < globsLength; j++ {
		t.Globs[j] = string(rcv.Globs(j))
	}
}

func (rcv *ConnectReply) UnPack() *ConnectReplyT {
	if rcv == nil {
		return nil
	}
	t := &ConnectReplyT{}
	rcv.UnPackTo(t)
	return t
}

type ConnectReply struct {
	_tab flatbuffers.Table
}

func GetRootAsConnectReply(buf []byte, offset flatbuffers.UOffsetT) *ConnectReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ConnectReply{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsConnectReply(buf []byte, offset flatbuffers.UOffsetT) *ConnectReply {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ConnectReply{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ConnectReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ConnectReply) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ConnectReply) LeakFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReply) LeakFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReply) RaceFrames(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReply) RaceFramesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReply) Features() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ConnectReply) MutateFeatures(n Feature) bool {
	return rcv._tab.MutateUint64Slot(8, uint64(n))
}

func (rcv *ConnectReply) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReply) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ConnectReply) Globs(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *ConnectReply) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func ConnectReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func ConnectReplyAddLeakFrames(builder *flatbuffers.Builder, leakFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(leakFrames), 0)
}
func ConnectReplyStartLeakFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyAddRaceFrames(builder *flatbuffers.Builder, raceFrames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(raceFrames), 0)
}
func ConnectReplyStartRaceFramesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyAddFeatures(builder *flatbuffers.Builder, features Feature) {
	builder.PrependUint64Slot(2, uint64(features), 0)
}
func ConnectReplyAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(files), 0)
}
func ConnectReplyStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(globs), 0)
}
func ConnectReplyStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ConnectReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoRequestT struct {
	Error    string       `json:"error"`
	Features Feature      `json:"features"`
	Globs    []*GlobInfoT `json:"globs"`
	Files    []*FileInfoT `json:"files"`
}

func (t *InfoRequestT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	errorOffset := builder.CreateString(t.Error)
	globsOffset := flatbuffers.UOffsetT(0)
	if t.Globs != nil {
		globsLength := len(t.Globs)
		globsOffsets := make([]flatbuffers.UOffsetT, globsLength)
		for j := 0; j < globsLength; j++ {
			globsOffsets[j] = t.Globs[j].Pack(builder)
		}
		InfoRequestStartGlobsVector(builder, globsLength)
		for j := globsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(globsOffsets[j])
		}
		globsOffset = builder.EndVector(globsLength)
	}
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = t.Files[j].Pack(builder)
		}
		InfoRequestStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	InfoRequestStart(builder)
	InfoRequestAddError(builder, errorOffset)
	InfoRequestAddFeatures(builder, t.Features)
	InfoRequestAddGlobs(builder, globsOffset)
	InfoRequestAddFiles(builder, filesOffset)
	return InfoRequestEnd(builder)
}

func (rcv *InfoRequest) UnPackTo(t *InfoRequestT) {
	t.Error = string(rcv.Error())
	t.Features = rcv.Features()
	globsLength := rcv.GlobsLength()
	t.Globs = make([]*GlobInfoT, globsLength)
	for j := 0; j < globsLength; j++ {
		x := GlobInfo{}
		rcv.Globs(&x, j)
		t.Globs[j] = x.UnPack()
	}
	filesLength := rcv.FilesLength()
	t.Files = make([]*FileInfoT, filesLength)
	for j := 0; j < filesLength; j++ {
		x := FileInfo{}
		rcv.Files(&x, j)
		t.Files[j] = x.UnPack()
	}
}

func (rcv *InfoRequest) UnPack() *InfoRequestT {
	if rcv == nil {
		return nil
	}
	t := &InfoRequestT{}
	rcv.UnPackTo(t)
	return t
}

type InfoRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoRequest(buf []byte, offset flatbuffers.UOffsetT) *InfoRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoRequest{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoRequest(buf []byte, offset flatbuffers.UOffsetT) *InfoRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoRequest) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *InfoRequest) Features() Feature {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return Feature(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *InfoRequest) MutateFeatures(n Feature) bool {
	return rcv._tab.MutateUint64Slot(6, uint64(n))
}

func (rcv *InfoRequest) Globs(obj *GlobInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequest) GlobsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoRequest) Files(obj *FileInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *InfoRequest) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func InfoRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func InfoRequestAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(error), 0)
}
func InfoRequestAddFeatures(builder *flatbuffers.Builder, features Feature) {
	builder.PrependUint64Slot(1, uint64(features), 0)
}
func InfoRequestAddGlobs(builder *flatbuffers.Builder, globs flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(globs), 0)
}
func InfoRequestStartGlobsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(files), 0)
}
func InfoRequestStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type InfoReplyT struct {
	CoverFilter []uint32 `json:"cover_filter"`
}

func (t *InfoReplyT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	coverFilterOffset := flatbuffers.UOffsetT(0)
	if t.CoverFilter != nil {
		coverFilterLength := len(t.CoverFilter)
		InfoReplyStartCoverFilterVector(builder, coverFilterLength)
		for j := coverFilterLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.CoverFilter[j])
		}
		coverFilterOffset = builder.EndVector(coverFilterLength)
	}
	InfoReplyStart(builder)
	InfoReplyAddCoverFilter(builder, coverFilterOffset)
	return InfoReplyEnd(builder)
}

func (rcv *InfoReply) UnPackTo(t *InfoReplyT) {
	coverFilterLength := rcv.CoverFilterLength()
	t.CoverFilter = make([]uint32, coverFilterLength)
	for j := 0; j < coverFilterLength; j++ {
		t.CoverFilter[j] = rcv.CoverFilter(j)
	}
}

func (rcv *InfoReply) UnPack() *InfoReplyT {
	if rcv == nil {
		return nil
	}
	t := &InfoReplyT{}
	rcv.UnPackTo(t)
	return t
}

type InfoReply struct {
	_tab flatbuffers.Table
}

func GetRootAsInfoReply(buf []byte, offset flatbuffers.UOffsetT) *InfoReply {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &InfoReply{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInfoReply(buf []byte, offset flatbuffers.UOffsetT) *InfoReply {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &InfoReply{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *InfoReply) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *InfoReply) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *InfoReply) CoverFilter(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *InfoReply) CoverFilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *InfoReply) MutateCoverFilter(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func InfoReplyStart(builder *flatbuffers.Builder) {
	builder.StartObject(1)
}
func InfoReplyAddCoverFilter(builder *flatbuffers.Builder, coverFilter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(coverFilter), 0)
}
func InfoReplyStartCoverFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InfoReplyEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type FileInfoT struct {
	Name   string `json:"name"`
	Exists bool   `json:"exists"`
	Error  string `json:"error"`
	Data   []byte `json:"data"`
}

func (t *FileInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	errorOffset := builder.CreateString(t.Error)
	dataOffset := flatbuffers.UOffsetT(0)
	if t.Data != nil {
		dataOffset = builder.CreateByteString(t.Data)
	}
	FileInfoStart(builder)
	FileInfoAddName(builder, nameOffset)
	FileInfoAddExists(builder, t.Exists)
	FileInfoAddError(builder, errorOffset)
	FileInfoAddData(builder, dataOffset)
	return FileInfoEnd(builder)
}

func (rcv *FileInfo) UnPackTo(t *FileInfoT) {
	t.Name = string(rcv.Name())
	t.Exists = rcv.Exists()
	t.Error = string(rcv.Error())
	t.Data = rcv.DataBytes()
}

func (rcv *FileInfo) UnPack() *FileInfoT {
	if rcv == nil {
		return nil
	}
	t := &FileInfoT{}
	rcv.UnPackTo(t)
	return t
}

type FileInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsFileInfo(buf []byte, offset flatbuffers.UOffsetT) *FileInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FileInfo{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFileInfo(buf []byte, offset flatbuffers.UOffsetT) *FileInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FileInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FileInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FileInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *FileInfo) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfo) Exists() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

func (rcv *FileInfo) MutateExists(n bool) bool {
	return rcv._tab.MutateBoolSlot(6, n)
}

func (rcv *FileInfo) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfo) Data(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *FileInfo) DataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *FileInfo) DataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *FileInfo) MutateData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func FileInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func FileInfoAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FileInfoAddExists(builder *flatbuffers.Builder, exists bool) {
	builder.PrependBoolSlot(1, exists, false)
}
func FileInfoAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(error), 0)
}
func FileInfoAddData(builder *flatbuffers.Builder, data flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(data), 0)
}
func FileInfoStartDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func FileInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type GlobInfoT struct {
	Name  string   `json:"name"`
	Files []string `json:"files"`
}

func (t *GlobInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	nameOffset := builder.CreateString(t.Name)
	filesOffset := flatbuffers.UOffsetT(0)
	if t.Files != nil {
		filesLength := len(t.Files)
		filesOffsets := make([]flatbuffers.UOffsetT, filesLength)
		for j := 0; j < filesLength; j++ {
			filesOffsets[j] = builder.CreateString(t.Files[j])
		}
		GlobInfoStartFilesVector(builder, filesLength)
		for j := filesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(filesOffsets[j])
		}
		filesOffset = builder.EndVector(filesLength)
	}
	GlobInfoStart(builder)
	GlobInfoAddName(builder, nameOffset)
	GlobInfoAddFiles(builder, filesOffset)
	return GlobInfoEnd(builder)
}

func (rcv *GlobInfo) UnPackTo(t *GlobInfoT) {
	t.Name = string(rcv.Name())
	filesLength := rcv.FilesLength()
	t.Files = make([]string, filesLength)
	for j := 0; j < filesLength; j++ {
		t.Files[j] = string(rcv.Files(j))
	}
}

func (rcv *GlobInfo) UnPack() *GlobInfoT {
	if rcv == nil {
		return nil
	}
	t := &GlobInfoT{}
	rcv.UnPackTo(t)
	return t
}

type GlobInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsGlobInfo(buf []byte, offset flatbuffers.UOffsetT) *GlobInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &GlobInfo{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsGlobInfo(buf []byte, offset flatbuffers.UOffsetT) *GlobInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &GlobInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *GlobInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *GlobInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *GlobInfo) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *GlobInfo) Files(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *GlobInfo) FilesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func GlobInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func GlobInfoAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func GlobInfoAddFiles(builder *flatbuffers.Builder, files flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(files), 0)
}
func GlobInfoStartFilesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func GlobInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type HostMessageT struct {
	Msg *HostMessagesT `json:"msg"`
}

func (t *HostMessageT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	HostMessageStart(builder)
	if t.Msg != nil {
		HostMessageAddMsgType(builder, t.Msg.Type)
	}
	HostMessageAddMsg(builder, msgOffset)
	return HostMessageEnd(builder)
}

func (rcv *HostMessage) UnPackTo(t *HostMessageT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *HostMessage) UnPack() *HostMessageT {
	if rcv == nil {
		return nil
	}
	t := &HostMessageT{}
	rcv.UnPackTo(t)
	return t
}

type HostMessage struct {
	_tab flatbuffers.Table
}

func GetRootAsHostMessage(buf []byte, offset flatbuffers.UOffsetT) *HostMessage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &HostMessage{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsHostMessage(buf []byte, offset flatbuffers.UOffsetT) *HostMessage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &HostMessage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *HostMessage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *HostMessage) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *HostMessage) MsgType() HostMessages {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return HostMessages(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *HostMessage) MutateMsgType(n HostMessages) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *HostMessage) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func HostMessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func HostMessageAddMsgType(builder *flatbuffers.Builder, msgType HostMessages) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func HostMessageAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func HostMessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutorMessageT struct {
	Msg *ExecutorMessagesT `json:"msg"`
}

func (t *ExecutorMessageT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	msgOffset := t.Msg.Pack(builder)

	ExecutorMessageStart(builder)
	if t.Msg != nil {
		ExecutorMessageAddMsgType(builder, t.Msg.Type)
	}
	ExecutorMessageAddMsg(builder, msgOffset)
	return ExecutorMessageEnd(builder)
}

func (rcv *ExecutorMessage) UnPackTo(t *ExecutorMessageT) {
	msgTable := flatbuffers.Table{}
	if rcv.Msg(&msgTable) {
		t.Msg = rcv.MsgType().UnPack(msgTable)
	}
}

func (rcv *ExecutorMessage) UnPack() *ExecutorMessageT {
	if rcv == nil {
		return nil
	}
	t := &ExecutorMessageT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutorMessage struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutorMessage(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutorMessage{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutorMessage(buf []byte, offset flatbuffers.UOffsetT) *ExecutorMessage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutorMessage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutorMessage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutorMessage) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutorMessage) MsgType() ExecutorMessages {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return ExecutorMessages(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecutorMessage) MutateMsgType(n ExecutorMessages) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *ExecutorMessage) Msg(obj *flatbuffers.Table) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		rcv._tab.Union(obj, o)
		return true
	}
	return false
}

func ExecutorMessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func ExecutorMessageAddMsgType(builder *flatbuffers.Builder, msgType ExecutorMessages) {
	builder.PrependByteSlot(0, byte(msgType), 0)
}
func ExecutorMessageAddMsg(builder *flatbuffers.Builder, msg flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(msg), 0)
}
func ExecutorMessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecRequestT struct {
	Id               int64       `json:"id"`
	ProgData         []byte      `json:"prog_data"`
	Flags            RequestFlag `json:"flags"`
	ExecEnv          ExecEnv     `json:"exec_env"`
	ExecFlags        ExecFlag    `json:"exec_flags"`
	SandboxArg       int64       `json:"sandbox_arg"`
	SignalFilter     []uint32    `json:"signal_filter"`
	SignalFilterCall int32       `json:"signal_filter_call"`
	Repeat           int32       `json:"repeat"`
}

func (t *ExecRequestT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	progDataOffset := flatbuffers.UOffsetT(0)
	if t.ProgData != nil {
		progDataOffset = builder.CreateByteString(t.ProgData)
	}
	signalFilterOffset := flatbuffers.UOffsetT(0)
	if t.SignalFilter != nil {
		signalFilterLength := len(t.SignalFilter)
		ExecRequestStartSignalFilterVector(builder, signalFilterLength)
		for j := signalFilterLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.SignalFilter[j])
		}
		signalFilterOffset = builder.EndVector(signalFilterLength)
	}
	ExecRequestStart(builder)
	ExecRequestAddId(builder, t.Id)
	ExecRequestAddProgData(builder, progDataOffset)
	ExecRequestAddFlags(builder, t.Flags)
	ExecRequestAddExecEnv(builder, t.ExecEnv)
	ExecRequestAddExecFlags(builder, t.ExecFlags)
	ExecRequestAddSandboxArg(builder, t.SandboxArg)
	ExecRequestAddSignalFilter(builder, signalFilterOffset)
	ExecRequestAddSignalFilterCall(builder, t.SignalFilterCall)
	ExecRequestAddRepeat(builder, t.Repeat)
	return ExecRequestEnd(builder)
}

func (rcv *ExecRequest) UnPackTo(t *ExecRequestT) {
	t.Id = rcv.Id()
	t.ProgData = rcv.ProgDataBytes()
	t.Flags = rcv.Flags()
	t.ExecEnv = rcv.ExecEnv()
	t.ExecFlags = rcv.ExecFlags()
	t.SandboxArg = rcv.SandboxArg()
	signalFilterLength := rcv.SignalFilterLength()
	t.SignalFilter = make([]uint32, signalFilterLength)
	for j := 0; j < signalFilterLength; j++ {
		t.SignalFilter[j] = rcv.SignalFilter(j)
	}
	t.SignalFilterCall = rcv.SignalFilterCall()
	t.Repeat = rcv.Repeat()
}

func (rcv *ExecRequest) UnPack() *ExecRequestT {
	if rcv == nil {
		return nil
	}
	t := &ExecRequestT{}
	rcv.UnPackTo(t)
	return t
}

type ExecRequest struct {
	_tab flatbuffers.Table
}

func GetRootAsExecRequest(buf []byte, offset flatbuffers.UOffsetT) *ExecRequest {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecRequest{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecRequest(buf []byte, offset flatbuffers.UOffsetT) *ExecRequest {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecRequest{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecRequest) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecRequest) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecRequest) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequest) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecRequest) ProgData(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecRequest) ProgDataLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequest) ProgDataBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecRequest) MutateProgData(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecRequest) Flags() RequestFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return RequestFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequest) MutateFlags(n RequestFlag) bool {
	return rcv._tab.MutateUint64Slot(8, uint64(n))
}

func (rcv *ExecRequest) ExecEnv() ExecEnv {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return ExecEnv(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequest) MutateExecEnv(n ExecEnv) bool {
	return rcv._tab.MutateUint64Slot(10, uint64(n))
}

func (rcv *ExecRequest) ExecFlags() ExecFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return ExecFlag(rcv._tab.GetUint64(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *ExecRequest) MutateExecFlags(n ExecFlag) bool {
	return rcv._tab.MutateUint64Slot(12, uint64(n))
}

func (rcv *ExecRequest) SandboxArg() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequest) MutateSandboxArg(n int64) bool {
	return rcv._tab.MutateInt64Slot(14, n)
}

func (rcv *ExecRequest) SignalFilter(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *ExecRequest) SignalFilterLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecRequest) MutateSignalFilter(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *ExecRequest) SignalFilterCall() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequest) MutateSignalFilterCall(n int32) bool {
	return rcv._tab.MutateInt32Slot(18, n)
}

func (rcv *ExecRequest) Repeat() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecRequest) MutateRepeat(n int32) bool {
	return rcv._tab.MutateInt32Slot(20, n)
}

func ExecRequestStart(builder *flatbuffers.Builder) {
	builder.StartObject(9)
}
func ExecRequestAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecRequestAddProgData(builder *flatbuffers.Builder, progData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(progData), 0)
}
func ExecRequestStartProgDataVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecRequestAddFlags(builder *flatbuffers.Builder, flags RequestFlag) {
	builder.PrependUint64Slot(2, uint64(flags), 0)
}
func ExecRequestAddExecEnv(builder *flatbuffers.Builder, execEnv ExecEnv) {
	builder.PrependUint64Slot(3, uint64(execEnv), 0)
}
func ExecRequestAddExecFlags(builder *flatbuffers.Builder, execFlags ExecFlag) {
	builder.PrependUint64Slot(4, uint64(execFlags), 0)
}
func ExecRequestAddSandboxArg(builder *flatbuffers.Builder, sandboxArg int64) {
	builder.PrependInt64Slot(5, sandboxArg, 0)
}
func ExecRequestAddSignalFilter(builder *flatbuffers.Builder, signalFilter flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(signalFilter), 0)
}
func ExecRequestStartSignalFilterVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ExecRequestAddSignalFilterCall(builder *flatbuffers.Builder, signalFilterCall int32) {
	builder.PrependInt32Slot(7, signalFilterCall, 0)
}
func ExecRequestAddRepeat(builder *flatbuffers.Builder, repeat int32) {
	builder.PrependInt32Slot(8, repeat, 0)
}
func ExecRequestEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type SignalUpdateT struct {
	NewMax  []uint32 `json:"new_max"`
	DropMax []uint32 `json:"drop_max"`
}

func (t *SignalUpdateT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	newMaxOffset := flatbuffers.UOffsetT(0)
	if t.NewMax != nil {
		newMaxLength := len(t.NewMax)
		SignalUpdateStartNewMaxVector(builder, newMaxLength)
		for j := newMaxLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.NewMax[j])
		}
		newMaxOffset = builder.EndVector(newMaxLength)
	}
	dropMaxOffset := flatbuffers.UOffsetT(0)
	if t.DropMax != nil {
		dropMaxLength := len(t.DropMax)
		SignalUpdateStartDropMaxVector(builder, dropMaxLength)
		for j := dropMaxLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.DropMax[j])
		}
		dropMaxOffset = builder.EndVector(dropMaxLength)
	}
	SignalUpdateStart(builder)
	SignalUpdateAddNewMax(builder, newMaxOffset)
	SignalUpdateAddDropMax(builder, dropMaxOffset)
	return SignalUpdateEnd(builder)
}

func (rcv *SignalUpdate) UnPackTo(t *SignalUpdateT) {
	newMaxLength := rcv.NewMaxLength()
	t.NewMax = make([]uint32, newMaxLength)
	for j := 0; j < newMaxLength; j++ {
		t.NewMax[j] = rcv.NewMax(j)
	}
	dropMaxLength := rcv.DropMaxLength()
	t.DropMax = make([]uint32, dropMaxLength)
	for j := 0; j < dropMaxLength; j++ {
		t.DropMax[j] = rcv.DropMax(j)
	}
}

func (rcv *SignalUpdate) UnPack() *SignalUpdateT {
	if rcv == nil {
		return nil
	}
	t := &SignalUpdateT{}
	rcv.UnPackTo(t)
	return t
}

type SignalUpdate struct {
	_tab flatbuffers.Table
}

func GetRootAsSignalUpdate(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdate {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SignalUpdate{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSignalUpdate(buf []byte, offset flatbuffers.UOffsetT) *SignalUpdate {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SignalUpdate{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SignalUpdate) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SignalUpdate) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *SignalUpdate) NewMax(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SignalUpdate) NewMaxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SignalUpdate) MutateNewMax(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *SignalUpdate) DropMax(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SignalUpdate) DropMaxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SignalUpdate) MutateDropMax(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func SignalUpdateStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func SignalUpdateAddNewMax(builder *flatbuffers.Builder, newMax flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(newMax), 0)
}
func SignalUpdateStartNewMaxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SignalUpdateAddDropMax(builder *flatbuffers.Builder, dropMax flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(dropMax), 0)
}
func SignalUpdateStartDropMaxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SignalUpdateEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecutingMessageT struct {
	Id     int64 `json:"id"`
	ProcId int32 `json:"proc_id"`
	Try    int32 `json:"try"`
}

func (t *ExecutingMessageT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	ExecutingMessageStart(builder)
	ExecutingMessageAddId(builder, t.Id)
	ExecutingMessageAddProcId(builder, t.ProcId)
	ExecutingMessageAddTry(builder, t.Try)
	return ExecutingMessageEnd(builder)
}

func (rcv *ExecutingMessage) UnPackTo(t *ExecutingMessageT) {
	t.Id = rcv.Id()
	t.ProcId = rcv.ProcId()
	t.Try = rcv.Try()
}

func (rcv *ExecutingMessage) UnPack() *ExecutingMessageT {
	if rcv == nil {
		return nil
	}
	t := &ExecutingMessageT{}
	rcv.UnPackTo(t)
	return t
}

type ExecutingMessage struct {
	_tab flatbuffers.Table
}

func GetRootAsExecutingMessage(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecutingMessage{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecutingMessage(buf []byte, offset flatbuffers.UOffsetT) *ExecutingMessage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecutingMessage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecutingMessage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecutingMessage) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecutingMessage) Id() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessage) MutateId(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *ExecutingMessage) ProcId() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessage) MutateProcId(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *ExecutingMessage) Try() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ExecutingMessage) MutateTry(n int32) bool {
	return rcv._tab.MutateInt32Slot(8, n)
}

func ExecutingMessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func ExecutingMessageAddId(builder *flatbuffers.Builder, id int64) {
	builder.PrependInt64Slot(0, id, 0)
}
func ExecutingMessageAddProcId(builder *flatbuffers.Builder, procId int32) {
	builder.PrependInt32Slot(1, procId, 0)
}
func ExecutingMessageAddTry(builder *flatbuffers.Builder, try int32) {
	builder.PrependInt32Slot(2, try, 0)
}
func ExecutingMessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type StatsMessageT struct {
	NoexecCount    int64 `json:"noexec_count"`
	NoexecDuration int64 `json:"noexec_duration"`
}

func (t *StatsMessageT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	StatsMessageStart(builder)
	StatsMessageAddNoexecCount(builder, t.NoexecCount)
	StatsMessageAddNoexecDuration(builder, t.NoexecDuration)
	return StatsMessageEnd(builder)
}

func (rcv *StatsMessage) UnPackTo(t *StatsMessageT) {
	t.NoexecCount = rcv.NoexecCount()
	t.NoexecDuration = rcv.NoexecDuration()
}

func (rcv *StatsMessage) UnPack() *StatsMessageT {
	if rcv == nil {
		return nil
	}
	t := &StatsMessageT{}
	rcv.UnPackTo(t)
	return t
}

type StatsMessage struct {
	_tab flatbuffers.Table
}

func GetRootAsStatsMessage(buf []byte, offset flatbuffers.UOffsetT) *StatsMessage {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &StatsMessage{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsStatsMessage(buf []byte, offset flatbuffers.UOffsetT) *StatsMessage {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &StatsMessage{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *StatsMessage) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *StatsMessage) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *StatsMessage) NoexecCount() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *StatsMessage) MutateNoexecCount(n int64) bool {
	return rcv._tab.MutateInt64Slot(4, n)
}

func (rcv *StatsMessage) NoexecDuration() int64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *StatsMessage) MutateNoexecDuration(n int64) bool {
	return rcv._tab.MutateInt64Slot(6, n)
}

func StatsMessageStart(builder *flatbuffers.Builder) {
	builder.StartObject(2)
}
func StatsMessageAddNoexecCount(builder *flatbuffers.Builder, noexecCount int64) {
	builder.PrependInt64Slot(0, noexecCount, 0)
}
func StatsMessageAddNoexecDuration(builder *flatbuffers.Builder, noexecDuration int64) {
	builder.PrependInt64Slot(1, noexecDuration, 0)
}
func StatsMessageEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type CallInfoT struct {
	Flags  CallFlag       `json:"flags"`
	Error  int32          `json:"error"`
	Signal []uint32       `json:"signal"`
	Cover  []uint32       `json:"cover"`
	Comps  []*ComparisonT `json:"comps"`
}

func (t *CallInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	signalOffset := flatbuffers.UOffsetT(0)
	if t.Signal != nil {
		signalLength := len(t.Signal)
		CallInfoStartSignalVector(builder, signalLength)
		for j := signalLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Signal[j])
		}
		signalOffset = builder.EndVector(signalLength)
	}
	coverOffset := flatbuffers.UOffsetT(0)
	if t.Cover != nil {
		coverLength := len(t.Cover)
		CallInfoStartCoverVector(builder, coverLength)
		for j := coverLength - 1; j >= 0; j-- {
			builder.PrependUint32(t.Cover[j])
		}
		coverOffset = builder.EndVector(coverLength)
	}
	compsOffset := flatbuffers.UOffsetT(0)
	if t.Comps != nil {
		compsLength := len(t.Comps)
		CallInfoStartCompsVector(builder, compsLength)
		for j := compsLength - 1; j >= 0; j-- {
			t.Comps[j].Pack(builder)
		}
		compsOffset = builder.EndVector(compsLength)
	}
	CallInfoStart(builder)
	CallInfoAddFlags(builder, t.Flags)
	CallInfoAddError(builder, t.Error)
	CallInfoAddSignal(builder, signalOffset)
	CallInfoAddCover(builder, coverOffset)
	CallInfoAddComps(builder, compsOffset)
	return CallInfoEnd(builder)
}

func (rcv *CallInfo) UnPackTo(t *CallInfoT) {
	t.Flags = rcv.Flags()
	t.Error = rcv.Error()
	signalLength := rcv.SignalLength()
	t.Signal = make([]uint32, signalLength)
	for j := 0; j < signalLength; j++ {
		t.Signal[j] = rcv.Signal(j)
	}
	coverLength := rcv.CoverLength()
	t.Cover = make([]uint32, coverLength)
	for j := 0; j < coverLength; j++ {
		t.Cover[j] = rcv.Cover(j)
	}
	compsLength := rcv.CompsLength()
	t.Comps = make([]*ComparisonT, compsLength)
	for j := 0; j < compsLength; j++ {
		x := Comparison{}
		rcv.Comps(&x, j)
		t.Comps[j] = x.UnPack()
	}
}

func (rcv *CallInfo) UnPack() *CallInfoT {
	if rcv == nil {
		return nil
	}
	t := &CallInfoT{}
	rcv.UnPackTo(t)
	return t
}

type CallInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsCallInfo(buf []byte, offset flatbuffers.UOffsetT) *CallInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CallInfo{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCallInfo(buf []byte, offset flatbuffers.UOffsetT) *CallInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CallInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CallInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CallInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *CallInfo) Flags() CallFlag {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return CallFlag(rcv._tab.GetByte(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *CallInfo) MutateFlags(n CallFlag) bool {
	return rcv._tab.MutateByteSlot(4, byte(n))
}

func (rcv *CallInfo) Error() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *CallInfo) MutateError(n int32) bool {
	return rcv._tab.MutateInt32Slot(6, n)
}

func (rcv *CallInfo) Signal(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *CallInfo) SignalLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfo) MutateSignal(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *CallInfo) Cover(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *CallInfo) CoverLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *CallInfo) MutateCover(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

func (rcv *CallInfo) Comps(obj *Comparison, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 16
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *CallInfo) CompsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func CallInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func CallInfoAddFlags(builder *flatbuffers.Builder, flags CallFlag) {
	builder.PrependByteSlot(0, byte(flags), 0)
}
func CallInfoAddError(builder *flatbuffers.Builder, error int32) {
	builder.PrependInt32Slot(1, error, 0)
}
func CallInfoAddSignal(builder *flatbuffers.Builder, signal flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(signal), 0)
}
func CallInfoStartSignalVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CallInfoAddCover(builder *flatbuffers.Builder, cover flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(cover), 0)
}
func CallInfoStartCoverVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func CallInfoAddComps(builder *flatbuffers.Builder, comps flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(comps), 0)
}
func CallInfoStartCompsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(16, numElems, 8)
}
func CallInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ComparisonT struct {
	Op1 uint64 `json:"op1"`
	Op2 uint64 `json:"op2"`
}

func (t *ComparisonT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	return CreateComparison(builder, t.Op1, t.Op2)
}
func (rcv *Comparison) UnPackTo(t *ComparisonT) {
	t.Op1 = rcv.Op1()
	t.Op2 = rcv.Op2()
}

func (rcv *Comparison) UnPack() *ComparisonT {
	if rcv == nil {
		return nil
	}
	t := &ComparisonT{}
	rcv.UnPackTo(t)
	return t
}

type Comparison struct {
	_tab flatbuffers.Struct
}

func (rcv *Comparison) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Comparison) Table() flatbuffers.Table {
	return rcv._tab.Table
}

func (rcv *Comparison) Op1() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(0))
}
func (rcv *Comparison) MutateOp1(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(0), n)
}

func (rcv *Comparison) Op2() uint64 {
	return rcv._tab.GetUint64(rcv._tab.Pos + flatbuffers.UOffsetT(8))
}
func (rcv *Comparison) MutateOp2(n uint64) bool {
	return rcv._tab.MutateUint64(rcv._tab.Pos+flatbuffers.UOffsetT(8), n)
}

func CreateComparison(builder *flatbuffers.Builder, op1 uint64, op2 uint64) flatbuffers.UOffsetT {
	builder.Prep(8, 16)
	builder.PrependUint64(op2)
	builder.PrependUint64(op1)
	return builder.Offset()
}

type ProgInfoT struct {
	Calls     []*CallInfoT `json:"calls"`
	Extra     *CallInfoT   `json:"extra"`
	Elapsed   uint64       `json:"elapsed"`
	Freshness uint64       `json:"freshness"`
}

func (t *ProgInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	callsOffset := flatbuffers.UOffsetT(0)
	if t.Calls != nil {
		callsLength := len(t.Calls)
		callsOffsets := make([]flatbuffers.UOffsetT, callsLength)
		for j := 0; j < callsLength; j++ {
			callsOffsets[j] = t.Calls[j].Pack(builder)
		}
		ProgInfoStartCallsVector(builder, callsLength)
		for j := callsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(callsOffsets[j])
		}
		callsOffset = builder.EndVector(callsLength)
	}
	extraOffset := t.Extra.Pack(builder)
	ProgInfoStart(builder)
	ProgInfoAddCalls(builder, callsOffset)
	ProgInfoAddExtra(builder, extraOffset)
	ProgInfoAddElapsed(builder, t.Elapsed)
	ProgInfoAddFreshness(builder, t.Freshness)
	return ProgInfoEnd(builder)
}

func (rcv *ProgInfo) UnPackTo(t *ProgInfoT) {
	callsLength := rcv.CallsLength()
	t.Calls = make([]*CallInfoT, callsLength)
	for j := 0; j < callsLength; j++ {
		x := CallInfo{}
		rcv.Calls(&x, j)
		t.Calls[j] = x.UnPack()
	}
	t.Extra = rcv.Extra(nil).UnPack()
	t.Elapsed = rcv.Elapsed()
	t.Freshness = rcv.Freshness()
}

func (rcv *ProgInfo) UnPack() *ProgInfoT {
	if rcv == nil {
		return nil
	}
	t := &ProgInfoT{}
	rcv.UnPackTo(t)
	return t
}

type ProgInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsProgInfo(buf []byte, offset flatbuffers.UOffsetT) *ProgInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ProgInfo{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsProgInfo(buf []byte, offset flatbuffers.UOffsetT) *ProgInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ProgInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ProgInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ProgInfo) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ProgInfo) Calls(obj *CallInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *ProgInfo) CallsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ProgInfo) Extra(obj *CallInfo) *CallInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(CallInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ProgInfo) Elapsed() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfo) MutateElapsed(n uint64) bool {
	return rcv._tab.MutateUint64Slot(8, n)
}

func (rcv *ProgInfo) Freshness() uint64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint64(o + rcv._tab.Pos)
	}
	return 0
}

func (rcv *ProgInfo) MutateFreshness(n uint64) bool {
	return rcv._tab.MutateUint64Slot(10, n)
}

func ProgInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ProgInfoAddCalls(builder *flatbuffers.Builder, calls flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(calls), 0)
}
func ProgInfoStartCallsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ProgInfoAddExtra(builder *flatbuffers.Builder, extra flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(extra), 0)
}
func ProgInfoAddElapsed(builder *flatbuffers.Builder, elapsed uint64) {
	builder.PrependUint64Slot(2, elapsed, 0)
}
func ProgInfoAddFreshness(builder *flatbuffers.Builder, freshness uint64) {
	builder.PrependUint64Slot(3, freshness, 0)
}
func ProgInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}

type ExecResultT struct {
	Executing *ExecutingMessageT `json:"executing"`
	Output    []byte             `json:"output"`
	Error     string             `json:"error"`
	Info      *ProgInfoT         `json:"info"`
}

func (t *ExecResultT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	executingOffset := t.Executing.Pack(builder)
	outputOffset := flatbuffers.UOffsetT(0)
	if t.Output != nil {
		outputOffset = builder.CreateByteString(t.Output)
	}
	errorOffset := builder.CreateString(t.Error)
	infoOffset := t.Info.Pack(builder)
	ExecResultStart(builder)
	ExecResultAddExecuting(builder, executingOffset)
	ExecResultAddOutput(builder, outputOffset)
	ExecResultAddError(builder, errorOffset)
	ExecResultAddInfo(builder, infoOffset)
	return ExecResultEnd(builder)
}

func (rcv *ExecResult) UnPackTo(t *ExecResultT) {
	t.Executing = rcv.Executing(nil).UnPack()
	t.Output = rcv.OutputBytes()
	t.Error = string(rcv.Error())
	t.Info = rcv.Info(nil).UnPack()
}

func (rcv *ExecResult) UnPack() *ExecResultT {
	if rcv == nil {
		return nil
	}
	t := &ExecResultT{}
	rcv.UnPackTo(t)
	return t
}

type ExecResult struct {
	_tab flatbuffers.Table
}

func GetRootAsExecResult(buf []byte, offset flatbuffers.UOffsetT) *ExecResult {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ExecResult{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsExecResult(buf []byte, offset flatbuffers.UOffsetT) *ExecResult {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ExecResult{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ExecResult) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ExecResult) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *ExecResult) Executing(obj *ExecutingMessage) *ExecutingMessage {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ExecutingMessage)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func (rcv *ExecResult) Output(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *ExecResult) OutputLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *ExecResult) OutputBytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResult) MutateOutput(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

func (rcv *ExecResult) Error() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *ExecResult) Info(obj *ProgInfo) *ProgInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(ProgInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

func ExecResultStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func ExecResultAddExecuting(builder *flatbuffers.Builder, executing flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(executing), 0)
}
func ExecResultAddOutput(builder *flatbuffers.Builder, output flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(output), 0)
}
func ExecResultStartOutputVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func ExecResultAddError(builder *flatbuffers.Builder, error flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(error), 0)
}
func ExecResultAddInfo(builder *flatbuffers.Builder, info flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(info), 0)
}
func ExecResultEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
