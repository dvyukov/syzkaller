package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"strings"
	"time"

	"github.com/google/syzkaller/pkg/osutil"
	"github.com/google/syzkaller/pkg/vcs"
	"github.com/google/syzkaller/sys/targets"
)

// git tag --list --no-contains HEAD --merged HEAD "v*.*"

func main() {
	var (
		flagSourceDir = flag.String("sourcedir", "", "sourcedir")
		flagConfig    = flag.String("config", "", "config")
	)
	flag.Parse()
	_ = flagSourceDir

	spec := &Spec{
		//Files: make(map[string]bool),
		Features:   make(map[string]bool),
		ConfigMap:  make(map[string]*Config),
		predicates: make(map[string]bool),
	}
	spec.parseFile(*flagConfig, false)
	target := targets.Get("linux", spec.Arch)
	if target == nil {
		failf("unknown arch %v", spec.Arch)
	}
	gen := &Generator{
		Target:    target,
		SourceDir: *flagSourceDir,
	}

	repo, err := vcs.NewRepo("linux", "", *flagSourceDir)
	if err != nil {
		failf("failed to create repo: %v", err)
	}
	fmt.Printf("git fetch %v %v...\n", spec.KernelRepo, spec.KernelTag)
	if _, err := repo.CheckoutCommit(spec.KernelRepo, spec.KernelTag); err != nil {
		failf("failed to checkout %v/%v: %v", spec.KernelRepo, spec.KernelTag, err)
	}
	gen.Make("mrproper")
	for _, defconfig := range spec.Defconfigs {
		gen.Make(defconfig)
	}
	fragmentFile, err := osutil.TempFile("syz-conf")
	if err != nil {
		failf("failed to create temp file: %v", err)
	}
	defer os.Remove(fragmentFile)
	buf := new(bytes.Buffer)
	for _, cfg := range spec.Configs {
		if cfg.Enabled {
			fmt.Fprintf(buf, "%v=%v\n", cfg.Name, cfg.Value)
		} else {
			fmt.Fprintf(buf, "# %v is not set\n", cfg.Name)
		}
	}
	if err := osutil.WriteFile(fragmentFile, buf.Bytes()); err != nil {
		failf("failed to write temp file: %v", err)
	}
	fmt.Printf("merging custom configs...\n")
	_, err = osutil.RunCmd(time.Minute, *flagSourceDir, "scripts/kconfig/merge_config.sh", "-m", ".config", fragmentFile)
	if err != nil {
		failf("failed to merge configs: %v", err)
	}
	// s/=m/=y/
	// Note: mod2yesconfig does this, but is not present in older kernels.
	kernelConfig, err := ioutil.ReadFile(filepath.Join(*flagSourceDir, ".config"))
	if err != nil {
		failf("failed to read kernel config: %v", err)
	}
	kernelConfig = bytes.ReplaceAll(kernelConfig, []byte("=m"), []byte("=y"))
	if err := osutil.WriteFile(filepath.Join(*flagSourceDir, ".config"), kernelConfig); err != nil {
		failf("failed to write kernel config: %v", err)
	}
	gen.Make("olddefconfig")

	//fmt.Printf("%+v\n", spec.predicates)

	actualSpec := &Spec{
		//Files: make(map[string]bool),
		Features:   make(map[string]bool),
		ConfigMap:  make(map[string]*Config),
		predicates: make(map[string]bool),
	}
	actualSpec.parseFile(filepath.Join(*flagSourceDir, ".config"), true)

	failed := false
	for _, cfg := range spec.Configs {
		if cfg.Pred != "" {
			continue
		}
		act := actualSpec.ConfigMap[cfg.Name]
		if act == nil {
			if cfg.Enabled {
				fmt.Printf("%v:%v: %v is not present in the final config\n",
					cfg.File, cfg.Line, cfg.Name)
				failed = true
			}
			continue
		}
		if cfg.Enabled != act.Enabled || cfg.Value != act.Value {
			fmt.Printf("%v:%v: %v=%v does not match final config %v=%v\n",
				cfg.File, cfg.Line, cfg.Name, cfg.Value, act.Name, act.Value)
			failed = true
		}
	}
	kernelConfig, err = ioutil.ReadFile(filepath.Join(*flagSourceDir, ".config"))
	if err != nil {
		failf("failed to read kernel config: %v", err)
	}
	kernelConfig = []byte(fmt.Sprintf(`# Automatically generated by syz-conf; DO NOT EDIT.
# Source: %v on %v %v

%s
%s
`, filepath.Base(*flagConfig), spec.KernelRepo, spec.KernelTag, spec.Verbatim, kernelConfig))
	outputFile := strings.TrimSuffix(*flagConfig, ".spec") + ".config"
	if failed {
		outputFile += ".tmp"
		//os.Exit(1)
	}
	fmt.Printf("writing %v\n", outputFile)
	if err := osutil.WriteFile(outputFile, kernelConfig); err != nil {
		failf("failed to write output file: %v", err)
	}
	if failed {
		os.Exit(1)
	}
}

type Generator struct {
	Target    *targets.Target
	SourceDir string
}

func (gen *Generator) Make(args ...string) {
	fmt.Printf("make %v...\n", args[0])
	args = append(args,
		"ARCH="+gen.Target.KernelArch,
		"-j", fmt.Sprint(runtime.NumCPU()),
	)
	if gen.Target.Triple != "" {
		args = append(args, "CROSS_COMPILE="+gen.Target.Triple+"-")
	}
	if gen.Target.KernelCompiler != "" {
		args = append(args, "CC="+gen.Target.KernelCompiler)
	}
	if _, err := osutil.RunCmd(10*time.Minute, gen.SourceDir, "make", args...); err != nil {
		failf("%v", err)
	}
}

type Spec struct {
	Arch       string
	Compiler   string
	KernelRepo string
	KernelTag  string
	Defconfigs []string
	Verbatim   []byte
	Features   map[string]bool
	ConfigMap  map[string]*Config
	Configs    []*Config

	predicates map[string]bool
}

type Config struct {
	Pred    string
	Name    string
	Value   string
	Enabled bool
	File    string
	Line    int
}

func (spec *Spec) parseFile(file string, kernelConfig bool) {
	f, err := os.Open(file)
	if err != nil {
		failf("failed to open config file: %v", err)
	}
	defer f.Close()
	s := bufio.NewScanner(f)
	for line := 1; s.Scan(); line++ {
		spec.parseLine(s.Text(), file, line, kernelConfig)
	}
	if err := s.Err(); err != nil {
		failf("failed to read config file: %v", err)
	}
}

var (
	reComment  = regexp.MustCompile(`^### .*$`)
	reInclude  = regexp.MustCompile(`^include ([a-z0-9/_.-]+)$`)
	reKernel   = regexp.MustCompile(`^kernel ((?:git|ssh|http|https|ftp|ftps)://[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]+)+(?::[0-9]+)?(?:/[a-zA-Z0-9-_./]+)?/?) ([a-zA-Z0-9\-/.]+)$`)
	reArch     = regexp.MustCompile(`^arch ([a-z0-9_]+)$`)
	reCompiler = regexp.MustCompile(`^compiler ([a-z0-9_\-]+)$`)
	reSet      = regexp.MustCompile(`^set ([A-Z]+)$`)
	reMake     = regexp.MustCompile(`^make ([a-z0-9_.]+)$`)
	reVerbatim = regexp.MustCompile(`^verbatim (.+)$`)
	reConfigY  = regexp.MustCompile(`^(?:([a-zA-Z0-9<>=_.]+): )?([A-Za-z0-9_]+)=(y|m|(?:[0-9]+)|(?:0x[0-9a-fA-F]+)|(?:".*?"))$`)
	reConfigN  = regexp.MustCompile(`^(?:([a-zA-Z0-9<>=_.]+): )?# ([A-Za-z0-9_]+) is not set$`)
)

func (spec *Spec) parseLine(text, file string, line int, kernelConfig bool) {
	if text == "" || reComment.MatchString(text) ||
		kernelConfig && strings.HasPrefix(text, "#") && !strings.HasPrefix(text, "# CONFIG_") {
	} else if match := reInclude.FindStringSubmatch(text); match != nil {
		spec.parseFile(filepath.Join(filepath.Dir(file), match[1]), false)
	} else if match := reKernel.FindStringSubmatch(text); match != nil {
		if spec.KernelRepo != "" {
			failf("%v:%v: kernel is already set to %v %v", file, line, spec.KernelRepo, spec.KernelTag)
		}
		spec.KernelRepo = match[1]
		spec.KernelTag = match[2]
	} else if match := reArch.FindStringSubmatch(text); match != nil {
		if spec.Arch != "" {
			failf("%v:%v: arch is already set to %v", file, line, spec.Arch)
		}
		spec.Arch = match[1]
	} else if match := reCompiler.FindStringSubmatch(text); match != nil {
		if spec.Compiler != "" {
			failf("%v:%v: compiler is already set to %v", file, line, spec.Compiler)
		}
		spec.Compiler = match[1]
		if strings.HasPrefix(spec.Compiler, "clang") {
			spec.Features["CLANG"] = true
		}
	} else if match := reMake.FindStringSubmatch(text); match != nil {
		spec.Defconfigs = append(spec.Defconfigs, match[1])
	} else if match := reSet.FindStringSubmatch(text); match != nil {
		if spec.Features[match[1]] {
			failf("%v:%v: feature %v is already set", file, line, match[1])
		}
		spec.Features[match[1]] = true
	} else if match := reVerbatim.FindStringSubmatch(text); match != nil {
		spec.Verbatim = append(append(spec.Verbatim, []byte(match[1])...), '\n')
	} else if match := reConfigY.FindStringSubmatch(text); match != nil {
		spec.addConfig(match[1], match[2], match[3], file, line)
	} else if match := reConfigN.FindStringSubmatch(text); match != nil {
		spec.addConfig(match[1], match[2], "", file, line)
	} else {
		failf("%v:%v: malformed line:\n%v", file, line, text)
	}
}

func (spec *Spec) addConfig(pred, name, val string, file string, line int) {
	if prev := spec.ConfigMap[name]; pred != "OVERRIDE" && prev != nil {
		failf("%v:%v: %v is already defined at %v:%v", file, line, name, prev.File, prev.Line)
	} else if pred == "OVERRIDE" && prev == nil {
		failf("%v:%v: %v nothing to override", file, line, name)
	}
	cfg := &Config{
		Pred:    pred,
		Name:    name,
		Value:   val,
		Enabled: val != "",
		File:    file,
		Line:    line,
	}
	if pred == "OVERRIDE" {
		*spec.ConfigMap[name] = *cfg
	} else {
		spec.ConfigMap[name] = cfg
		spec.Configs = append(spec.Configs, cfg)
	}
	spec.predicates[pred] = true
}

func failf(msg string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, msg+"\n", args...)
	os.Exit(1)
}
