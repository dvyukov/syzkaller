// Copyright 2019 syzkaller project authors. All rights reserved.
// Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

// +build

package main

import (
	"bytes"
	"path/filepath"
	"sort"
	"text/template"

	"github.com/google/syzkaller/pkg/osutil"
	"github.com/google/syzkaller/sys/feature"
	"github.com/google/syzkaller/sys/targets"
)

func main() {
	w := new(bytes.Buffer)
	if err := enumTempl.Execute(w, feature.All); err != nil {
		panic(err)
	}
	if err := osutil.WriteFile("enum.go", w.Bytes()); err != nil {
		panic(err)
	}
	var executorData []ExecutorData
	for os := range targets.List {
		data := ExecutorData{OS: os}
		for _, meta := range feature.All {
			if meta.SupportedOn(os) {
				data.Features = append(data.Features, meta)
			}
		}
		executorData = append(executorData, data)
	}
	sort.Slice(executorData, func(i, j int) bool {
		return executorData[i].OS < executorData[j].OS
	})
	w.Reset()
	if err := executorTempl.Execute(w, executorData); err != nil {
		panic(err)
	}
	if err := osutil.WriteFile(filepath.FromSlash("../../executor/features.h"), w.Bytes()); err != nil {
		panic(err)
	}
}

type ExecutorData struct {
	OS       string
	Features []feature.Feature
}

var enumTempl = template.Must(template.New("").Parse(`// AUTOGENERATED FILE

package feature

type flags struct { {{range $i, $f := .}}
	{{$f.Name}} bool{{end}}
}

const ({{range $i, $f := .}}
	{{$f.Name}} ID = {{$i}}{{end}}
)

func field(flags *flags, index int) *bool {
	switch index { {{range $i, $f := .}}
	case {{$i}}: return &flags.{{$f.Name}}{{end}}
	default: panic("unknown feature")
	}	
}
`))

var executorTempl = template.Must(template.New("").Parse(`// AUTOGENERATED FILE
{{range $os := .}}
#if GOOS_{{$os.OS}}
{{range $feat := $os.Features}}
static bool flag_{{$feat.CppName}};{{end}}

{{range $feat := $os.Features}}{{if $feat.OS}}
#define SYZ_HAVE_{{$feat.MacroName}} 1{{end}}{{end}}

{{range $feat := $os.Features}}{{if $feat.NeedSetup}}
static void setup_{{$feat.CppName}}();{{end}}{{end}}

static const struct feature_t features[] = { {{range $feat := $os.Features}}
	[{{$feat.ID}}] = {&flag_{{$feat.CppName}}, "{{$feat.Name}}"{{if $feat.NeedSetup}}, setup_{{$feat.CppName}}{{end}}},{{end}}
};
#endif
{{end}}
`))
