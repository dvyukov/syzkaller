# Copyright 2018 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

# AF_NETLINK/NETLINK_ROUTE support.

include <linux/net.h>
include <linux/netdevice.h>
include <uapi/linux/if.h>
include <uapi/linux/if_link.h>
include <uapi/linux/if_addr.h>
include <uapi/linux/netlink.h>
include <uapi/linux/netconf.h>
include <uapi/linux/rtnetlink.h>
include <uapi/linux/lwtunnel.h>
include <uapi/linux/neighbour.h>

resource sock_nl_route[sock_netlink]

socket$nl_route(domain const[AF_NETLINK], type const[SOCK_RAW], proto const[NETLINK_ROUTE]) sock_nl_route

sendmsg$nl_route(fd sock_nl_route, msg ptr[in, msghdr_netlink[netlink_msg_route]], f flags[send_flags])

netlink_msg_route [
	newlink			netlink_msg[RTM_NEWLINK, ifinfomsg[AF_UNSPEC], ifla_policy]
	getlink			netlink_msg[RTM_GETLINK, ifinfomsg[AF_UNSPEC], ifla_policy]
	setlink			netlink_msg[RTM_SETLINK, ifinfomsg[AF_UNSPEC], ifla_policy]
	dellink			netlink_msg[RTM_DELLINK, ifinfomsg[AF_UNSPEC], ifla_policy]

	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, 0);
	rtnl_register(PF_UNSPEC, RTM_GETNETCONF, NULL, rtnl_dump_all, 0);



	rtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_DELNEIGH, neigh_delete, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_GETNEIGH, NULL, neigh_dump_info, 0);
	rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info,
	rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL, 0);
	rtnl_register(PF_UNSPEC, RTM_GETSTATS, rtnl_stats_get, rtnl_stats_dump,






	ipv4_newaddr		netlink_msg[RTM_NEWADDR, ifaddrmsg[AF_INET], ifa_ipv4_policy]
	ipv4_deladdr		netlink_msg[RTM_DELADDR, ifaddrmsg[AF_INET], ifa_ipv4_policy]
	ipv4_getaddr		netlink_msg[RTM_GETADDR, ifaddrmsg[AF_INET], ifa_ipv4_policy]
	ipv4_newroute		netlink_msg[RTM_NEWROUTE, rtmsg[AF_INET], rtm_ipv4_policy]
	ipv4_delroute		netlink_msg[RTM_DELROUTE, rtmsg[AF_INET], rtm_ipv4_policy]
	ipv4_getroute		netlink_msg[RTM_GETROUTE, rtgenmsg[AF_INET], void]
	ipv4_getnetconf		netlink_msg[RTM_GETNETCONF, netconfmsg[AF_INET], devconf_ip_policy]

	ipv6_newaddr		netlink_msg[RTM_NEWADDR, ifaddrmsg[AF_INET6], ifa_ipv6_policy]
	ipv6_deladdr		netlink_msg[RTM_DELADDR, ifaddrmsg[AF_INET6], ifa_ipv6_policy]
	ipv6_getaddr		netlink_msg[RTM_GETADDR, ifaddrmsg[AF_INET6], ifa_ipv6_policy]
	ipv6_newroute		netlink_msg[RTM_NEWROUTE, rtmsg[AF_INET6], rtm_ipv6_policy]
	ipv6_delroute		netlink_msg[RTM_DELROUTE, rtmsg[AF_INET6], rtm_ipv6_policy]
	ipv6_getroute		netlink_msg[RTM_GETROUTE, rtmsg[AF_INET6], rtm_ipv6_policy]
	ipv6_getmulticast	netlink_msg[RTM_GETMULTICAST, rtgenmsg[AF_INET6], void]
	ipv6_getanyicast	netlink_msg[RTM_GETANYCAST, rtgenmsg[AF_INET6], void]
	ipv6_getnetconf		netlink_msg[RTM_GETNETCONF, netconfmsg[AF_INET6], devconf_ip_policy]

	ipmr_newroute		netlink_msg[RTM_NEWROUTE, rtmsg[RTNL_FAMILY_IPMR], rtm_ipv4_policy]
	ipmr_delroute		netlink_msg[RTM_DELROUTE, rtmsg[RTNL_FAMILY_IPMR], rtm_ipv4_policy]
	ipmr_getroute		netlink_msg[RTM_GETROUTE, rtgenmsg[RTNL_FAMILY_IPMR], void]

	mpls_newroute		netlink_msg[RTM_NEWROUTE, rtmsg[AF_MPLS], rtm_mpls_policy]
	mpls_delroute		netlink_msg[RTM_DELROUTE, rtmsg[AF_MPLS], rtm_mpls_policy]
	mpls_getroute		netlink_msg[RTM_GETROUTE, rtmsg[AF_MPLS], rtm_mpls_policy]
	mpls_getnetconf		netlink_msg[RTM_GETNETCONF, netconfmsg[AF_MPLS], devconf_mpls_policy]

	bridge_newneigh		netlink_msg[RTM_NEWNEIGH, ndmsg, rtm_mpls_policy]
	bridge_delneigh		netlink_msg[RTM_DELNEIGH, ndmsg, rtm_mpls_policy]
	bridge_getneigh		netlink_msg[RTM_GETNEIGH, rtgenmsg[AF_BRIDGE], rtm_mpls_policy]

	rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, rtnl_fdb_add, NULL, 0);
	rtnl_register(PF_BRIDGE, RTM_DELNEIGH, rtnl_fdb_del, NULL, 0);
	rtnl_register(PF_BRIDGE, RTM_GETNEIGH, NULL, rtnl_fdb_dump, 0);

	#rtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, rtnl_bridge_getlink, 0);
	#rtnl_register(PF_BRIDGE, RTM_DELLINK, rtnl_bridge_dellink, NULL, 0);
	#rtnl_register(PF_BRIDGE, RTM_SETLINK, rtnl_bridge_setlink, NULL, 0);

] [varlen]


	NDA_UNSPEC,
	NDA_DST,
	NDA_LLADDR,
	NDA_CACHEINFO,
	NDA_PROBES,
	NDA_VLAN,
	NDA_PORT,
	NDA_VNI,
	NDA_IFINDEX,
	NDA_MASTER,
	NDA_LINK_NETNSID,
	NDA_SRC_VNI,
	
	

type rtgenmsg[FAMILY] {
	rtgen_family	const[FAMILY, int8]
}

type netconfmsg[FAMILY] {
	ncm_family	const[FAMILY, int8]
}

type ifinfomsg[FAMILY] {
	ifi_family	const[FAMILY, int8]
	__ifi_pad	const[0, int8]
	ifi_type	const[0, int16]
	ifi_index	ifindex[opt]
	ifi_flags	flags[net_device_flags, int32]
	ifi_change	flags[net_device_flags, int32]
}

type ifaddrmsg[FAMILY] {
	ifa_family	const[FAMILY, int8]
	ifa_prefixlen	flags[ifa_prefixlen, int8]
	ifa_flags	flags[ifa_flags, int8]
	ifa_scope	flags[rt_scope_t, int8]
	ifa_index	ifindex
}

type rtmsg[FAMILY] {
	rtm_family	const[FAMILY, int8]
	rtm_dst_len	flags[rtm_addr_len, int8]
	rtmsrcdst_len	flags[rtm_addr_len, int8]
	rtm_tos		int8
	rtm_table	flags[rt_table_types, int8]
	rtm_protocol	flags[rtm_protocol, int8]
	rtm_scope	flags[rt_scope_t, int8]
	rtm_type	flags[rtm_type, int8]
	rtm_flags	flags[rtm_flags, int32]
}

ndmsg {
	ndm_family	flags[rtnl_af, int8]
	ndm_pad1	const[0, int8]
	ndm_pad2	const[0, int16]
	ndm_ifindex	ifindex
	ndm_state	flags[ndm_state, int16]
	ndm_flags	flags[ndm_flags, int8]
	ndm_type	flags[rtm_type, int8]
}

ifla_policy [
	IFLA_IFNAME		nlattr[IFLA_IFNAME, devname]
	IFLA_ADDRESS		nlattr[IFLA_ADDRESS, mac_addr]
	IFLA_BROADCAST		nlattr[IFLA_BROADCAST, mac_addr]
	IFLA_MAP		nlattr[IFLA_MAP, rtnl_link_ifmap]
	IFLA_MTU		nlattr[IFLA_MAP, int32]
	IFLA_LINK		nlattr[IFLA_LINK, int32]
	IFLA_MASTER		nlattr[IFLA_MASTER, int32]
	IFLA_CARRIER		nlattr[IFLA_CARRIER, int8]
	IFLA_TXQLEN		nlattr[IFLA_TXQLEN, int32]
	IFLA_WEIGHT		nlattr[IFLA_WEIGHT, int32]
	IFLA_OPERSTATE		nlattr[IFLA_OPERSTATE, int8]
	IFLA_LINKMODE		nlattr[IFLA_LINKMODE, int8]
	IFLA_LINKINFO		nlattr[IFLA_LINKINFO, array[ifla_info_policy]]
	IFLA_NET_NS_PID		nlattr[IFLA_NET_NS_PID, pid]
# TODO: this must be some 'nsfd' fd.
	IFLA_NET_NS_FD		nlattr[IFLA_NET_NS_FD, fd]
	IFLA_IFALIAS		nlattr[IFLA_IFALIAS, devname]
	IFLA_IFALIASn		nlattr[IFLA_IFALIAS, void]
	IFLA_VFINFO_LIST	nlattr[IFLA_VFINFO_LIST, array[nlattr[IFLA_VF_INFO, array[ifla_vf_policy]]]]
	IFLA_VF_PORTS		nlattr[IFLA_VF_PORTS, array[nlattr[IFLA_VF_PORT, array[ifla_port_policy]]]]
	IFLA_PORT_SELF		nlattr[IFLA_PORT_SELF, array[ifla_port_policy]]
	IFLA_AF_SPEC		nlattr[IFLA_AF_SPEC, array[nlattr_t[flags[rtnl_af, int16], void]]]
	IFLA_EXT_MASK		nlattr[IFLA_EXT_MASK, int32]
	IFLA_PROMISCUITY	nlattr[IFLA_PROMISCUITY, int32]
	IFLA_NUM_TX_QUEUES	nlattr[IFLA_NUM_TX_QUEUES, int32]
	IFLA_NUM_RX_QUEUES	nlattr[IFLA_NUM_RX_QUEUES, int32]
	IFLA_PHYS_PORT_ID	nlattr[IFLA_PHYS_PORT_ID, array[int8, 0:MAX_PHYS_ITEM_ID_LEN]]
	IFLA_CARRIER_CHANGES	nlattr[IFLA_CARRIER_CHANGES, int32]
	IFLA_PHYS_SWITCH_ID	nlattr[IFLA_PHYS_SWITCH_ID, array[int8, 0:MAX_PHYS_ITEM_ID_LEN]]
# TODO: this is some net namespace id.
	IFLA_LINK_NETNSID	nlattr[IFLA_LINK_NETNSID, int32]
	IFLA_PROTO_DOWN		nlattr[IFLA_PROTO_DOWN, int8]
	IFLA_XDP		nlattr[IFLA_XDP, array[ifla_xdp_policy]]
	IFLA_EVENT		nlattr[IFLA_EVENT, int32]
	IFLA_GROUP		nlattr[IFLA_GROUP, int32]
# TODO: probably also some net namespace id.
	IFLA_IF_NETNSID		nlattr[IFLA_IF_NETNSID, int32]
] [varlen]

ifla_info_policy [
	IFLA_INFO_KIND		nlattr[IFLA_INFO_KIND, string]
# TODO: strictly saying this and IFLA_INFO_SLAVE_DATA is yet another NLA_NESTED.
	IFLA_INFO_DATA		nlattr[IFLA_INFO_DATA, array[int8]]
	IFLA_INFO_SLAVE_KIND	nlattr[IFLA_INFO_SLAVE_KIND, string]
	IFLA_INFO_SLAVE_DATA	nlattr[IFLA_INFO_SLAVE_DATA, array[int8]]
] [varlen]

ifa_ipv4_policy [
	IFA_LOCAL	nlattr[IFA_LOCAL, ipv4_addr]
	IFA_ADDRESS	nlattr[IFA_ADDRESS, ipv4_addr]
	IFA_BROADCAST	nlattr[IFA_BROADCAST, ipv4_addr]
	IFA_LABEL	nlattr[IFA_LABEL, devname]
	IFA_CACHEINFO	nlattr[IFA_CACHEINFO, ifa_cacheinfo]
	IFA_FLAGS	nlattr[IFA_FLAGS, flags[ifa_flags, int32]]
] [varlen]

ifa_ipv6_policy [
	IFA_ADDRESS	nlattr[IFA_ADDRESS, ipv6_addr]
	IFA_LOCAL	nlattr[IFA_LOCAL, ipv6_addr]
	IFA_CACHEINFO	nlattr[IFA_CACHEINFO, ifa_cacheinfo]
	IFA_FLAGS	nlattr[IFA_FLAGS, flags[ifa_flags, int32]]
] [varlen]

rtm_ipv4_policy [
	RTA_DST		nlattr[RTA_DST, ipv4_addr]
	RTA_SRC		nlattr[RTA_SRC, ipv4_addr]
	RTA_IIF		nlattr[RTA_DST, ifindex]
	RTA_OIF		nlattr[RTA_OIF, ifindex]
	RTA_GATEWAY	nlattr[RTA_GATEWAY, ipv4_addr]
	RTA_PRIORITY	nlattr[RTA_PRIORITY, int32]
	RTA_PREFSRC	nlattr[RTA_PREFSRC, ipv4_addr]
# TODO: what's this? is this interesting?
	RTA_METRICS	nlattr[RTA_METRICS, array[int8]]
	RTA_MULTIPATH	nlattr[RTA_MULTIPATH, array[rtnexthop]]
	RTA_FLOW	nlattr[RTA_FLOW, int32]
	RTA_ENCAP_TYPE	nlattr[RTA_ENCAP_TYPE, flags[lwtunnel_encap_types, int16]]
# TODO: describe RTA_ENCAP
	RTA_ENCAP	nlattr[RTA_ENCAP, nl_generic_attr]
	RTA_UID		nlattr[RTA_UID, uid]
	RTA_MARK	nlattr[RTA_MARK, int32]
] [varlen]

rtm_ipv6_policy [
	RTA_GATEWAY	nlattr[RTA_GATEWAY, ipv6_addr]
	RTA_IIF		nlattr[RTA_DST, ifindex]
	RTA_OIF		nlattr[RTA_OIF, ifindex]
	RTA_PRIORITY	nlattr[RTA_PRIORITY, int32]
# TODO: what's this? is this interesting?
	RTA_METRICS	nlattr[RTA_METRICS, array[int8]]
	RTA_MULTIPATH	nlattr[RTA_MULTIPATH, array[rtnexthop]]
	RTA_PREF	nlattr[RTA_PREF, int8]
	RTA_ENCAP_TYPE	nlattr[RTA_ENCAP_TYPE, flags[lwtunnel_encap_types, int16]]
# TODO: describe RTA_ENCAP
	RTA_ENCAP	nlattr[RTA_ENCAP, nl_generic_attr]
	RTA_EXPIRES	nlattr[RTA_MARK, int32]
	RTA_UID		nlattr[RTA_UID, uid]
	RTA_MARK	nlattr[RTA_MARK, int32]
] [varlen]

static const struct nla_policy rtm_mpls_policy[RTA_MAX+1] = {
	[RTA_DST]		= { .type = NLA_U32 },
	[RTA_OIF]		= { .type = NLA_U32 },
	[RTA_TTL_PROPAGATE]	= { .type = NLA_U8 },
};

rtnexthop {
	rtnh_len	int16
	rtnh_flags	int8
	rtnh_hops	int8
	rtnh_ifindex	ifindex
}

ifa_cacheinfo {
	ifa_prefered	int32
	ifa_valid	int32
	cstamp		int32
	tstamp		int32
}

devconf_ip_policy [
	NETCONFA_IFINDEX		nlattr[NETCONFA_IFINDEX, ifindex]
	NETCONFA_FORWARDING		nlattr[NETCONFA_FORWARDING, int32]
	NETCONFA_RP_FILTER		nlattr[NETCONFA_RP_FILTER, int32]
	NETCONFA_PROXY_NEIGH		nlattr[NETCONFA_PROXY_NEIGH, int32]
	IGNORE_ROUTES_WITH_LINKDOWN	nlattr[NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN, int32]
] [varlen]

static const struct nla_policy devconf_mpls_policy[NETCONFA_MAX + 1] = {
	[NETCONFA_IFINDEX]	= { .len = sizeof(int) },
};

# TODO: implement these
type ifla_vf_policy nl_generic_attr
type ifla_port_policy nl_generic_attr
type ifla_xdp_policy nl_generic_attr

dev_addr [
	empty	array[const[0, int8], MAX_ADDR_LEN]
	mac	mac_addr
] [varlen]

rtnl_link_ifmap {
	mem_start	int64
	mem_end		int64
	base_addr	int64
	irq		int16
	dma		int8
	port		int8
}

rtnl_af = AF_INET, AF_INET6, AF_BRIDGE, AF_MPLS
net_device_flags = IFF_UP, IFF_BROADCAST, IFF_DEBUG, IFF_LOOPBACK, IFF_POINTOPOINT, IFF_NOTRAILERS, IFF_RUNNING, IFF_NOARP, IFF_PROMISC, IFF_ALLMULTI, IFF_MASTER, IFF_SLAVE, IFF_MULTICAST, IFF_PORTSEL, IFF_AUTOMEDIA, IFF_DYNAMIC, IFF_LOWER_UP, IFF_DORMANT, IFF_ECHO
ifa_flags = IFA_F_SECONDARY, IFA_F_NODAD, IFA_F_OPTIMISTIC, IFA_F_DADFAILED, IFA_F_HOMEADDRESS, IFA_F_DEPRECATED, IFA_F_TENTATIVE, IFA_F_PERMANENT, IFA_F_MANAGETEMPADDR, IFA_F_NOPREFIXROUTE, IFA_F_MCAUTOJOIN
rt_scope_t = RT_SCOPE_UNIVERSE, RT_SCOPE_SITE, RT_SCOPE_LINK, RT_SCOPE_HOST, RT_SCOPE_NOWHERE
rtm_protocol = RTPROT_UNSPEC, RTPROT_REDIRECT, RTPROT_KERNEL, RTPROT_BOOT, RTPROT_STATIC
rtm_type = RTN_UNSPEC, RTN_UNICAST, RTN_LOCAL, RTN_BROADCAST, RTN_ANYCAST, RTN_MULTICAST, RTN_BLACKHOLE, RTN_UNREACHABLE, RTN_PROHIBIT, RTN_THROW, RTN_NAT, RTN_XRESOLVE
rtm_flags = RTM_F_NOTIFY, RTM_F_CLONED, RTM_F_EQUALIZE, RTM_F_PREFIX, RTM_F_LOOKUP_TABLE, RTM_F_FIB_MATCH
lwtunnel_encap_types = LWTUNNEL_ENCAP_NONE, LWTUNNEL_ENCAP_MPLS, LWTUNNEL_ENCAP_IP, LWTUNNEL_ENCAP_ILA, LWTUNNEL_ENCAP_IP6, LWTUNNEL_ENCAP_SEG6, LWTUNNEL_ENCAP_BPF, LWTUNNEL_ENCAP_SEG6_LOCAL
rt_table_types = RT_TABLE_UNSPEC, RT_TABLE_COMPAT, RT_TABLE_DEFAULT, RT_TABLE_MAIN, RT_TABLE_LOCAL
ndm_state = NUD_INCOMPLETE, NUD_REACHABLE, NUD_STALE, NUD_DELAY, NUD_PROBE, NUD_FAILED, NUD_NOARP, NUD_PERMANENT, NUD_NONE
ndm_flags = NTF_USE, NTF_SELF, NTF_MASTER, NTF_PROXY, NTF_EXT_LEARNED, NTF_OFFLOADED, NTF_ROUTER
ifa_prefixlen = 0, 1, 8, 16, 24, 31, 32, 56, 63, 64, 128
rtm_addr_len = 0, 16, 20, 32, 128
